<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>bastionsofwill</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="bastionsofwill">
<meta property="og:url" content="https://bastionsofwill.github.io/index.html">
<meta property="og:site_name" content="bastionsofwill">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="JY">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="bastionsofwill" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">bastionsofwill</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="검색"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://bastionsofwill.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-hexo-travis-ghpage" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/17/hexo-travis-ghpage/" class="article-date">
  <time class="dt-published" datetime="2021-11-17T16:17:58.000Z" itemprop="datePublished">2021-11-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/17/hexo-travis-ghpage/">Hexo 튜토리얼: Travis CI를 사용한 Github Pages 블로그 운영</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Hexo란"><a href="#Hexo란" class="headerlink" title="Hexo란?"></a>Hexo란?</h2><p>Hexo는 GitHub Pages를 사용한 블로깅에 자주 사용되는 Jekyll과 비슷한 블로깅 프레임워크이다. Ruby Gem 형태로 사용되어 Ruby 개발환경을 세팅해야 하는 Jekyll에 비해 내 환경에 이미 설치되어있던 Node.js와 Git 두 요구사항에 의존하는 점이 마음에 들어서 사용하게 되었다.</p>
<p>Hexo는 지정 폴더의 리소스를 관리하여 블로그 애셋을 생성/배포하는 방식으로 작동한다.<br><code>hexo init &lt;folder&gt;</code> 명령어로 블로깅에 사용할 폴더를 초기화하면 아래와 같은 형태의 구조를 갖추게 된다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>draft 폴더에 마크다운 파일을 생성하고 <code>hexo publish</code> 명령어로 이를 post로 옮겨서 게시글 작성을 관리할 수 있으며, scaffolds를 통해 사전에 정의해둔 포맷으로 게시글을 생성할 수 있다. 각 게시글 상단에 Front-matter라는 YAML 또는 JSON 형식의 메타데이터를 입력하여 해당 게시글의 제목, 태그 등의 정보를 지정할 수 있다.<br>게시글 작성을 마치고 _post 폴더로 옮긴 다음에는 .md 형식의 파일을 HTML, CSS, JS로 구성된 정적 페이지로의 변환하는 과정이 필요하다. 이를 수행하는 명령어가 <code>hexo generate</code>로, 로컬 환경에서 이를 실행한 후 호스팅하는 방식으로 사용할 수도 있겠지만, hexo는 다양한 방식의 보다 편리한 배포 및 관리를 지원한다.</p>
<h2 id="GitHub-Pages와-Travis-CI를-사용한-블로그-퍼블리싱"><a href="#GitHub-Pages와-Travis-CI를-사용한-블로그-퍼블리싱" class="headerlink" title="GitHub Pages와 Travis CI를 사용한 블로그 퍼블리싱"></a>GitHub Pages와 Travis CI를 사용한 블로그 퍼블리싱</h2><p>hexo는 git, heroku 등 다양한 환경에 맞는 배포 툴을 지원하지만, GitHub Pages를 사용하는 Hexo의 공식 튜토리얼에서는 Travis CI라는 CI 툴을 사용하여 배포를 진행한다.<br>Travis CI에 GitHub Pages 리포지토리(<strong><em>username</em>.github.io</strong>) 권한을 부여한 후, <code>.travis.yml</code> 파일을 리포지토리에 추가하여 <code>main</code> 브랜치에서 <code>gh-pages</code> 브랜치로의 배포를 자동화할 수 있다. <code>.travis.yml</code> 파일에는 <code>hexo generate</code> 명령어를 사용하여 정적 파일을 생성하는 스크립트가 설정되어 있다. 이후 리포지토리 설정에서 <code>gh-pages</code> 브랜치 내용을 GitHub Pages 사이트 소스로 설정하면, <strong><em>username</em>.github.io</strong>로 사용자의 블로그를 호스팅할 수 있다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://hexo.io/ko/docs/setup">https://hexo.io/ko/docs/setup</a><br><a target="_blank" rel="noopener" href="https://hexo.io/ko/docs/github-pages">https://hexo.io/ko/docs/github-pages</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/11/17/hexo-travis-ghpage/" data-id="ckw65m9v6000f4hoyb8ucf4qf" data-title="Hexo 튜토리얼: Travis CI를 사용한 Github Pages 블로그 운영" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GitHub-Pages/" rel="tag">GitHub Pages</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travis-CI/" rel="tag">Travis CI</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-video-through-web-0" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/05/video-through-web-0/" class="article-date">
  <time class="dt-published" datetime="2021-10-05T19:48:36.000Z" itemprop="datePublished">2021-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/05/video-through-web-0/">Adobe Flash와 ActiveX</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="웹-상에서의-사용자-경험에-대한-갈증"><a href="#웹-상에서의-사용자-경험에-대한-갈증" class="headerlink" title="웹 상에서의 사용자 경험에 대한 갈증"></a>웹 상에서의 사용자 경험에 대한 갈증</h2><p>웹을 통해 사용자에게 하이퍼텍스트 이상의 경험, 다시 말해 영상과 소리, 또는 게임 등의 상호작용이 가능한 컨텐츠를 전달하려면 어떻게 해야 할까? 클라이언트의 웹 브라우저는 HTTP 통신으로 정보를 주고받지만, 기존에 주고받던 데이터의 형태인 텍스트와 정적인 이미지에 비해 훨씬 많은 자원을 요구하는 이러한 컨텐츠를 웹을 통해 전달하고 경험하기 위해서는 특별한 고려가 필요하다. 이를 해결하기 위해 등장한 수많은 해답 중 하나인 RIA와 Browser Plugin 기술에 대해 알아보자.</p>
<h2 id="Rich-Internet-Application-RIA-RWA-Rich-Web-Appliction"><a href="#Rich-Internet-Application-RIA-RWA-Rich-Web-Appliction" class="headerlink" title="Rich Internet Application(RIA, RWA=Rich Web Appliction)"></a>Rich Internet Application(RIA, RWA=Rich Web Appliction)</h2><p>웹 상에서 사용자 경험을 향상시키기 위한 브라우저 확장 프로그램으로, 데스크탑 애플리케이션의 특징을 갖는 웹 애플리케이션이다. Adobe Flash의 전신인 Macromedia Flash MX로 만든 프로덕트를 설명하기 위한 개념으로 처음 소개되었으며, Java applet, 어도비 플래시, MS 실버라이트 등의 플러그인 기술로 개발한 웹 애플리케이션을 칭하는 개념으로 확장되었다.<br>주로 브라우저의 멀티미디어/그래픽 성능을 보강하는 역할을 했지만, 브라우저, 운영체제 등 클라이언트의 환경에 따라 RIA 요소를 전부 따로 고려하여야 했기 때문에 크로스 브라우징을 지원할 때 심각한 장애 요소로 작용하여 현대의 웹에서는 퇴출되었다.</p>
<h2 id="NPAPI-Netscape-Plugin-API-와-ActiveX"><a href="#NPAPI-Netscape-Plugin-API-와-ActiveX" class="headerlink" title="NPAPI(Netscape Plugin API)와 ActiveX"></a>NPAPI(Netscape Plugin API)와 ActiveX</h2><p>NPAPI는 넷스케이프에서 개발한, 브라우저가 외부 애플리케이션(= RIA)을 브라우저에서 플러그인 형식으로 끌어다 쓰기 위한 API이다. 다시 말하면, 브라우저에서 동작하기 어려운 기능을 구현하기 위해 클라이언트 환경에 애플리케이션을 설치한 뒤, 이를 웹 페이지에서 접근하기 위해 사용하는 API이다.<br>이것이 대세가 되면서 플래시 등의 플러그인 기술들은 이를 기반으로 개발되고, MS는 이에 대응하기 위해 IE3에 NPAPI 지원 기능을 추가하면서도 한편으로는 윈도우 + IE 환경에서만 사용이 가능한 자체 플러그인 규격인 ActiveX를 만들었다.<br>이후 IE가 시장에서 지배적인 위치를 차지하면서 IE는 NPAPI 지원을 중단하였고, ActiveX는 웹 환경에서의 보다 다양한 경험 및 기능을 위한 표준이 되어버리나, 지나친 권한을 허용함으로서 사용자의 보안을 저해하고, 여러 플랫폼에서 호환이 되지 않는 등 여러 부작용을 가져온다.<br>이러한 심각한 문제점과 모바일 기반 환경의 폭발적인 성장, 파이어폭스/크롬 등 경쟁자의 등장 등이 맞물리면서 윈도우 및 IE의 독점적인 지위는 하락세를 걸었고, 크로스 브라우징 및 웹 표준에 대한 논의가 등장하면서 ActiveX(비슷한 문제를 가지고 있던 NPAPI까지도)는 마침내 퇴출된다.</p>
<h2 id="어도비-플래시-플래시-플레이어-액션스크립트"><a href="#어도비-플래시-플래시-플레이어-액션스크립트" class="headerlink" title="어도비 플래시, 플래시 플레이어, 액션스크립트"></a>어도비 플래시, 플래시 플레이어, 액션스크립트</h2><ul>
<li>어도비 플래시: RIA를 포함하는 다양한 프로덕트(animations, rich web applications, desktop applications, mobile apps, mobile games, and embedded web browser video players)를 개발하는 플랫폼(Java applets, MS Silverlight와 같은 레벨)</li>
<li>어도비 플래시 플레이어: 어도비 플래시에서 생산된 컨텐츠 파일(SWF 파일)을 실행하는 가상 머신</li>
<li>액션스크립트: 어도비 플래시에서의 사용(애플리케이션 개발)을 목적으로 만들어진 스크립트 언어 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/10/05/video-through-web-0/" data-id="ckw65m9vc000m4hoydeag7q37" data-title="Adobe Flash와 ActiveX" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/history/" rel="tag">history</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-what-is-ssl-certificate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/06/what-is-ssl-certificate/" class="article-date">
  <time class="dt-published" datetime="2021-08-06T16:28:37.000Z" itemprop="datePublished">2021-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/06/what-is-ssl-certificate/">SSL/TLS와 인증서의 이해</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SSL-TLS란"><a href="#SSL-TLS란" class="headerlink" title="SSL/TLS란?"></a>SSL/TLS란?</h2><ul>
<li>SSL(Secure Socket Layer)은 암호 기반의 인터넷 보안 프로토콜</li>
<li>여러 번의 보완이 있었으며, 넷스케이프와 무관한 IETF가 이를 관리하면서 TLS(Transport Layer Security)로 이름이 변경</li>
<li>HTTP가 이를 사용하여 HTTPS(HTTP over TLS)를 제공하며, SNMP, FTP 등 다른 프로토콜에서도 SSL/TLS를 사용</li>
<li>현재 SSL은 업데이트가 중단되어 많은 보안 취약점이 있고, 대다수의 웹 브라우저는 SSL을 지원하지 않는다.</li>
<li>따라서 대부분의 경우 엄밀하게 말하자면 TLS라 표기하는 것이 맞지만, SSL이 TLS를 지칭하는 용어로 자주 혼용된다.</li>
</ul>
<h2 id="SSL-TLS의-기능"><a href="#SSL-TLS의-기능" class="headerlink" title="SSL/TLS의 기능"></a>SSL/TLS의 기능</h2><ul>
<li>Encryption: 웹 상에서 전송되는 데이터를 암호화하여, 전송 중인 데이터를 탈취하여도 의미없게 만든다.</li>
<li>Authentication: Handshake라는 두 기기 간 인증 절차를 거침으로서 서로가 서로임을 보장해준다.</li>
<li>Integrity: 디지털 서명을 통해 데이터 무결성, 즉 데이터가 변조되지 않았음을 검증한다.</li>
</ul>
<h2 id="SSL-certificate-TLS-certificate-란"><a href="#SSL-certificate-TLS-certificate-란" class="headerlink" title="SSL certificate(TLS certificate)란?"></a>SSL certificate(TLS certificate)란?</h2><ul>
<li>웹사이트의 서버 또는 앱 서버에 저장되어 웹사이트를 인증해주는 일종의 신분증이다.</li>
<li>인증서에는 아래와 같은 정보가 포함되어 있다.<ul>
<li>도메인 네임</li>
<li>발급받은 주체(개인, 단체, 기기)</li>
<li>발급 주체(CA)</li>
<li>CA의 디지털 서명</li>
<li>적용받는 서브도메인들</li>
<li>발급 날짜</li>
<li>만료 날짜</li>
<li>퍼블릭 키</li>
</ul>
</li>
<li>인증서에는 웹사이트의 퍼블릭 키가 포함되어 사용자 디바이스는 이를 통해 웹사이트와 안전한 연결을 할 수 있도록 한다.</li>
<li>웹사이트는 별도 관리하는 프라이빗 키로 사용자가 전달한 퍼블릭 키로 암호화된 데이터를 복호화한다.</li>
<li>CA(Certificate Authorities)는 SSL 인증서를 발급해주는 기관이다.</li>
</ul>
<h2 id="SSL-certificate-validation-level"><a href="#SSL-certificate-validation-level" class="headerlink" title="SSL certificate validation level"></a>SSL certificate validation level</h2><ul>
<li>Domain Validation<ul>
<li>가장 낮은 수준의 검증</li>
<li>비용 저렴</li>
<li>해당 도메인의 control 여부만 증명: 이는 보통 DNS 레코드나 이메일을 통해 검증 </li>
</ul>
</li>
<li>Organization Validation<ul>
<li>CA가 직접 인증서를 발급받는 주체와 접촉하여 검증</li>
<li>인증서에는 해당 단체의 이름과 주소 등을 포함</li>
</ul>
</li>
<li>Extended Validation<ul>
<li>SSL 인증서 발급 전, 해당 환경과 단체에 관한 폭넓은 검증</li>
<li>단체가 정말 존재하며 법적 문제 없이 등록되어있느지 등을 조사</li>
<li>시간과 비용 필요</li>
</ul>
</li>
</ul>
<h2 id="안전한-상태란"><a href="#안전한-상태란" class="headerlink" title="안전한 상태란?"></a>안전한 상태란?</h2><ul>
<li>클라이언트가 신뢰할 수 있는 상태의 인증서</li>
<li>안전한 설정<ul>
<li>안전한 프로토콜 제공(Protocol support)</li>
<li>안전한 암호(Secure Cipher Suites) 설정</li>
</ul>
</li>
</ul>
<h2 id="클라이언트가-신뢰할-수-있는-인증서"><a href="#클라이언트가-신뢰할-수-있는-인증서" class="headerlink" title="클라이언트가 신뢰할 수 있는 인증서"></a>클라이언트가 신뢰할 수 있는 인증서</h2><ol>
<li><p>서비스 도메인에 적합한 인증서 유형의 확인</p>
<ul>
<li>FQDN(Fully Qualified Domain Name: Subdomain부터 TLD까지 포함하는 완전한 도메인 이름)에 대한 개별 인증서</li>
<li>SAN(Subject Alternative Name) 인증서: 여러 FQDN에 대한 신뢰를 한번에 제공</li>
<li>Wildcard 인증서<ul>
<li>‘*’을 접두사로 사용하여 서브도메인 전체에 대한 신뢰 제공</li>
<li>첫 번째 레벨 서브 도메인에 대해서만 커버 가능: 두 번째 이하 레벨은 신뢰하지 않음</li>
</ul>
</li>
</ul>
</li>
<li><p>신뢰할 수 있는 root CA의 선택</p>
<ul>
<li>Certificate Transparency<ul>
<li>Google의 Certificate Transparency(<a target="_blank" rel="noopener" href="https://certificate.transparency.dev/">https://certificate.transparency.dev</a>) 참여 여부</li>
<li>향후 SCT(Signed Certificate Timestamp) 대응 계획</li>
<li>특정 도메인에 대한 인증서 발급 현황에 대해 누구나 조회 가능(<a target="_blank" rel="noopener" href="https://crt.sh/">https://crt.sh</a>)</li>
</ul>
</li>
<li>CA/Browser Forum(<a target="_blank" rel="noopener" href="https://cabforum.org)의/">https://cabforum.org)의</a> Base Requirement에 따른 운영 여부</li>
</ul>
</li>
<li><p>인증서 프라이빗 키를 안전하게 보관</p>
<ul>
<li>인증서를 발급받을 경우 보통 아래와 같은 파일들이 생성<table>
<thead>
<tr>
<th>Index</th>
<th>Purpose</th>
<th>Filename</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CA로부터 서명 받은 인증서(X.509 형식)</td>
<td>cert.pem</td>
</tr>
<tr>
<td>2</td>
<td>인증서의 개인키(Certificate’s private key)</td>
<td>privkey.pem</td>
</tr>
<tr>
<td>3</td>
<td>중간 CA의 인증서</td>
<td>chain.pem</td>
</tr>
<tr>
<td>4</td>
<td>Fullchain(1+3 combined)</td>
<td>fullchain.pem</td>
</tr>
</tbody></table>
</li>
<li>2번 파일인 인증서의 개인키는 안전한 곳에서 최초 생성 후 접근 불가하도록 설정</li>
<li>나머지 파일들은 클라이언트가 접속할 때 전달</li>
</ul>
</li>
<li><p>웹서버에서 적절한 중간 CA 인증서 설정: 클라이언트에서 Chain of Trust 확인</p>
<ul>
<li>위 테이블의 3, 4번 파일</li>
<li>클라이언트가 인증서를 신뢰할 수 있는 근거를 전달하는 절차</li>
<li>클라이언트는 접속할 서버에서 보낸 인증서 내용 확인 후 신뢰할 수 있는 CA의 서명을 확인</li>
<li>클라이언트가 전달받은 leaf 인증서를 서명한 중간 CA 정보와, 중간 CA를 서명한 root CA가 이미 신뢰하는 root CA의 목록에 있는지 차례대로 확인(Chain of Trust)하여 검증</li>
<li>따라서, 중간 CA 정보를 클라이언트에 전달하지 못하면 root CA에 대한 신뢰관계를 검증하지 못할 수도(대부분 클라이언트들은 신뢰하는 중간 CA 정보도 설정하기 때문에 문제가 없는 경우가 많음) 있기 때문에 중간 CA 정보를 설정하는 것이 좋음</li>
<li>root CA와 중간 CA를 굳이 분리하는 것은 신뢰구조 전체가 무너지는 것을 방지하기 위함이며, root CA는 중간 CA를 서명하기 위해서만 제한적으로 사용되고 실제 발급되는 leaf 인증서의 발급(서명)에는 중간 CA를 사용하는 구조가 보편적.<br><img src="/images/Chain_Of_Trust.png"></li>
<li>CSR(Cross Signed Root): 클라이언트의 신뢰하는 root CA 목록에 해당 root CA가 포함되지 않을 수 있는데(클라이언트 환경이 오래되었거나, root CA가 비교적 최근에 작성되었을 경우), 이 경우 대부분의 클라이언트가 신뢰하는 root CA에게 별도로 서명을 받아두기도 하며 이를 CSR이라 한다.</li>
<li>SNI(Server Name Indication): 여러 도메인을 하나의 웹 서버로 서비스할 때, 접속하고자 하는 호스트네임을 요청하여 적절한 인증서를 받아 오기 위해 SNI를 지원하는 클라이언트 환경이 요구될 수 있다.</li>
</ul>
</li>
</ol>
<h2 id="안전한-설정"><a href="#안전한-설정" class="headerlink" title="안전한 설정"></a>안전한 설정</h2><ol>
<li>사용하는 OpenSSL 라이브러리의 지속적인 업데이트<ul>
<li>라이브러리 커플링: 웹서버 설치 시 OpenSSL 라이브러리를 정적으로 빌드하면 업데이트할 시 웹서버를 새로 빌드/배포해야 하므로, 시스템 라이브러리를 사용하여 웹서버와 분리할 것을 권장</li>
</ul>
</li>
<li>안전하지 않은 프로토콜의 배제<ul>
<li>TLS는 지속적으로 보안 수준을 높여가고 있으므로 최신 버전 프로토콜만 사용하도록 하는 것이 바람직하나, 호환성을 고려하여 상황에 따라 결정</li>
</ul>
</li>
<li>안전한 cipher suite 설정<ul>
<li>Cipher Suite: 안전한 연결 생성을 위한 4개의 암호화 알고리즘<ol>
<li>키 교환(Key exchange/agreement)</li>
<li>접속 시 상대 확인(Authentication)</li>
<li>기밀성을 위한 블록 암호화(Block/stream cipher)</li>
<li>메시지 무결성을 위한 암호화(Message authentication)</li>
</ol>
</li>
<li>cipher suite를 구성하는 알고리즘을 결정하는 데 있어 대규모 트래픽 처리 시 성능을 고려해야 할 때도 있으므로 테스트를 해보는 것이 좋음 </li>
</ul>
</li>
</ol>
<p>출처:<br><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-ssl/">https://www.cloudflare.com/learning/ssl/what-is-ssl/</a><br><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/</a><br><a target="_blank" rel="noopener" href="https://engineering.linecorp.com/ko/blog/best-practices-to-secure-your-ssl-tls/">https://engineering.linecorp.com/ko/blog/best-practices-to-secure-your-ssl-tls/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/08/06/what-is-ssl-certificate/" data-id="ckw65m9vn001t4hoygjzgdsw2" data-title="SSL/TLS와 인증서의 이해" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/infrastructure/" rel="tag">infrastructure</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">network</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tslop-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/01/tslop-05/" class="article-date">
  <time class="dt-published" datetime="2021-08-01T13:18:02.000Z" itemprop="datePublished">2021-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/01/tslop-05/">The Secret Life of Programs - 05. Computer Architecture</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="프로시저-서브루틴-함수"><a href="#프로시저-서브루틴-함수" class="headerlink" title="프로시저, 서브루틴, 함수"></a>프로시저, 서브루틴, 함수</h2><ul>
<li>함수를 호출, 실행하고 다시 원래 자리로 돌아오기 위해서는 어디서 함수를 호출하였는지를 기억해야 하는데, 이는 바로 프로그램 카운터의 값이다.</li>
<li>반환 주소를 저장하고, 이를 간접 호출하여 분기해서 돌아오는 과정은 많은 작업이 필요하므로 대부분의 기계는 이를 구현한 명령어를 제공한다.</li>
</ul>
<h2 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h2><ul>
<li>반환 위치 저장할 메모리 주소가 하나뿐이라면 반환 위치가 덮어씌워지기 때문에 재귀 함수를 사용할 수 없다.</li>
<li>따라서, 함수를 호출할 때에는 반환 위치를 LIFO로 가져오기 위해 스택을 사용하며, 스택의 크기를 초과하는 것을 스택 오버플로, 빈 스택에서 데이터를 가져오려고 하는 경우를 스택 언더플로라 한다.</li>
<li>함수가 호출될 때마다 반환 주소 이외에도 각각의 독립된 로컬 변수를 사용하기 때문에, 로컬 변수 역시 스택에 저장하면 각각의 함수 호출을 독립적으로 구성할 수 있다. 이렇게 매 함수 호출 시 스택에 저장되는 데이터의 모음을 스택 프레임이라 한다.</li>
</ul>
<h2 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h2><ul>
<li>폴링(Polling)은 자원을 많이 소비할 수 있으므로, 인터럽트 시스템이 필요하다.</li>
<li>인터럽트 요청이 발생하면, 처리중인 명령어까지는 마무리한 후 프로그램을 중단하고 인터럽트 핸들러라는 프로그램(함수)을 실행하고, 다시 원래 프로그램이 중단된 위치부터 실행을 계속한다.</li>
<li>이를 위해 인터럽트에 대응하고 실행 중이던 프로그램으로 돌아가기까지 걸리는 시간을 제한해야 하며, 스택에 인터럽트 발생 이전의 상태를 저장하였다가 복구해줘야 한다.</li>
<li>인터럽트 벡터: 컴퓨터는 각 인터럽트에 대응하는 인터럽트 핸들러 주소를 지정하는 포인터를 가지고 있는데, 이를 인터럽트 벡터라 한다.</li>
</ul>
<h2 id="상대-주소-지정"><a href="#상대-주소-지정" class="headerlink" title="상대 주소 지정"></a>상대 주소 지정</h2><ul>
<li>여러 프로그램을 동시에 사용할 때, 타이머를 통해 각 프로그램이 실행되는 시간을 제한하여 스위칭하는 스케줄링 방식을 시분할이라 한다.</li>
<li>이를 위해 각 프로그램에 다른 공간을 허용하는데, 이 때 한 프로그램이 다른 프로그램이 사용하는 메모리에 접근하면 여러 가지 문제가 발생할 수 있다.</li>
<li>이를 방지하기 위해 메모리 주소를 절대적으로 지정하는 것은 바람직하지 않으며, 상대 주소 지정을 통해 프로그램이 접근할 수 있는 메모리 주소를 재배치한다.</li>
</ul>
<h2 id="메모리-관리-장치"><a href="#메모리-관리-장치" class="headerlink" title="메모리 관리 장치"></a>메모리 관리 장치</h2><ul>
<li>한 프로그램이 의도치 않게, 또는 의도적으로 허용되지 않은 메모리에 접근하는 것은 바람직하지 않으므로 이를 위해 메모리 관리 장치(Memory Management Unit)이 사용된다.</li>
<li>프로그램은 가상 주소를 사용하여 작성되고, MMU는 이를 물리적 주소로 변환하는 역할을 한다.</li>
<li>MMU는 페이징 기법을 활용하여 실제 가능한 물리주소 범위보다 넓은 범위의 가상 주소를 사용할 수 있게 해준다.</li>
</ul>
<h2 id="가상-메모리"><a href="#가상-메모리" class="headerlink" title="가상 메모리"></a>가상 메모리</h2><ul>
<li>MMU의 페이징 기법으로 확장된 메모리 가용 영역보다 더 큰 영역이 필요할 경우, OS는 현재 필요하지 않은 페이지를 느리지만 용량이 큰 디스크로 옮겨버리고(swap out), 추후 다시 접근이 필요할 때 다시 메모리에 불러들인다(swap in).</li>
<li>이는 성능을 크게 저하시키지만, 메모리가 부족해서 실행할 수 없는 프로그램을 실행할 수 있게 해준다.</li>
</ul>
<h2 id="메모리-계층과-성능"><a href="#메모리-계층과-성능" class="headerlink" title="메모리 계층과 성능"></a>메모리 계층과 성능</h2><ul>
<li>CPU에 비해 메모리가 느리기 때문에, 메모리 계층이라는 개념을 적용, CPU에 캐시라는 하드웨어를 추가하여 CPU가 필요로 할 가능성이 높은 데이터를 미리 읽어옴으로써 성능 향상을 기대할 수 있다.</li>
</ul>
<h2 id="메모리상의-데이터-배치"><a href="#메모리상의-데이터-배치" class="headerlink" title="메모리상의 데이터 배치"></a>메모리상의 데이터 배치</h2><ul>
<li>실행 전에는 크기를 알 수 없는 데이터, 즉 동적 데이터를 다루기 위해 힙(heap)이라는 영역을 사용한다.</li>
</ul>
<h2 id="프로그램-실행"><a href="#프로그램-실행" class="headerlink" title="프로그램 실행"></a>프로그램 실행</h2><ul>
<li>링커는 재사용 등을 위해 조각난 프로그램을 하나로 연결하여 실행 가능한 프로그램을 만들어주는 프로그램이다.</li>
<li>라이브러리를 프로그램에 직접 가져다 붙이는 방식을 정적 링크라 하고, 공유 라이브러리를 사용하여 여러 프로그램이 같은 라이브러리를 사용할 수 있도록 하는 방식을 동적 링크라 한다.</li>
<li>공유 라이브러리의 명령어는 해당 라이브러리를 사용하는 모든 프로그램에서 공통이므로, 라이브러리 함수를 작성할 때는 호출하는 프로그램의 스택과 힙을 사용하도록 함수를 설계한다.</li>
<li>프로그램이 합쳐져 실행파일이 되면, 런타임 라이브러리가 추가되어 프로그램 실행시 가장 먼저 실행되고 이후 진입점의 명령어가 수행되면서 프로그램이 실행된다.</li>
<li>런타임 라이브러리는 프로그램이 사용할 메모리 설정을 수행하면서 스택과 힙 영역을 설정하고 데이터의 초깃값도 설정하는 역할을 한다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/08/01/tslop-05/" data-id="ckw65m9vb000k4hoy28h20arx" data-title="The Secret Life of Programs - 05. Computer Architecture" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fundamental/" rel="tag">fundamental</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/the-secret-life-of-programs/" rel="tag">the-secret-life-of-programs</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tslop-04" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/01/tslop-04/" class="article-date">
  <time class="dt-published" datetime="2021-08-01T13:17:04.000Z" itemprop="datePublished">2021-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/01/tslop-04/">The Secret Life of Programs - 04. Computer Anatomy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul>
<li>Arithmatic Logic Unit: 연산자와 피연산자를 입력받아 결과값과 결과 코드를 리턴</li>
<li>Shifter: 조합 논리(Combinational Logic)만으로는 구현할 수 없는 Shift 연산을 수행</li>
<li>Excecution Unit<ul>
<li>메모리에서 명령과 피연산자를 가져와서 ALU에 전달하고 리턴값을 메모리에 저장</li>
<li>메모리에서 실행해야하는 명령의 위치를 기억하기 위해 메모리 위치를 참조하는 PC(Program Counter)를 사용</li>
</ul>
</li>
</ul>
<h2 id="명령어-집합"><a href="#명령어-집합" class="headerlink" title="명령어 집합"></a>명령어 집합</h2><ul>
<li>명령어(instruction)를 네 필드(opcode, 두 개의 operand, result)로 나누어 표시한다면 아래 2가지 문제점으로 인하여 명령어를 처리하기 어렵다.<ol>
<li>operand와 result 필드에 들어가는 주소 값으로 쓸 수 있는 비트가 부족</li>
<li>한 번에 여러 메모리 주소에 접근해야 함</li>
</ol>
</li>
<li>따라서 opcode와 주소로만 구성된 single-address 명령어를 사용하며, 이를 위해 누산기(accumulator)라는 레지스터를 사용한다.</li>
<li>그럼에도 모든 메모리 주소 영역을 명령어에 담을 수 없으므로 3종류의 주소 지정 모드(즉시, 직접, 간접)를 통해 참조할 수 있는 주소의 영역을 확장한다.</li>
<li>따라서 명령어의 구성은 아래 이미지와 같이 나타낼 수 있다.<br><img src="/images/instruction_set.png"></li>
</ul>
<h2 id="메모리-입-출력-CPU-명령어"><a href="#메모리-입-출력-CPU-명령어" class="headerlink" title="메모리 + 입/출력 + CPU + 명령어"></a>메모리 + 입/출력 + CPU + 명령어</h2><ul>
<li>컴퓨터는 메모리에서 명령어를 가져오는 상태(fetch)와 명령을 실행하는 상태(execute)를 반복</li>
<li>즉, 컴퓨터의 처리 방식은 프로그램 카운터 값을 메모리의 주소 버스에 먹이고, 메모리의 값(수행해야 하는 명령어)을 다시 명령어 레지스터에 먹여 명령어를 저장하는 절차의 반복</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/08/01/tslop-04/" data-id="ckw65m9v8000i4hoy2y1sefos" data-title="The Secret Life of Programs - 04. Computer Anatomy" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fundamental/" rel="tag">fundamental</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/the-secret-life-of-programs/" rel="tag">the-secret-life-of-programs</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-email-tracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/22/email-tracking/" class="article-date">
  <time class="dt-published" datetime="2021-07-22T19:03:20.000Z" itemprop="datePublished">2021-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/22/email-tracking/">이메일 개봉/링크 클릭 추적하기</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Open-Tracking"><a href="#Open-Tracking" class="headerlink" title="Open Tracking"></a>Open Tracking</h2><p>Open tracking은 이메일 수신자가 해당 이메일을 개봉하였는지를 알려준다. 이를 위해 메일침프는 이메일 HTML 하단에 Open tracker(또는 Web beacon)이라는, 캠페인별로 유니크한 작은 투명 그래픽을 임베드한다. 이후 수신자가 해당 메일을 열게 되면, 그 투명 그래픽을 메일침프 서버에서 다운받게 되면서 메일 개봉 처리가 된다. Out-of-office같은 자동화 답장은 그래픽을 다운받지 않기 때문에 미개봉으로 처리된다.<br>Web beacon을 사용한 추적은 Open tracking을 위한 표준이며, 구독자의 참여 정도를 알 수 있게 해주지만 몇 가지 제약 사항이 따른다. 숨겨진 그래픽 이미지를 기반으로 작동하기 때문에 수신자가 이메일을 열람하는 환경에 따라서 작동하지 않을 수 있는데, 예를 들어 이메일 클라이언트가 해당 이미지를 표기하지 않는 경우에는 작동하지 않는다.</p>
<h2 id="Click-Tracking"><a href="#Click-Tracking" class="headerlink" title="Click Tracking"></a>Click Tracking</h2><p>수신자가 메일에 포함된 URL을 클릭하게 되면, 해당 URL은 Mailchimp의 서버를 경유하여 로그에 기록된 후 목표 주소에 리다이렉트된다. </p>
<h2 id="What-is-Link-Branding"><a href="#What-is-Link-Branding" class="headerlink" title="What is Link Branding?"></a>What is Link Branding?</h2><p>이메일 링크 브랜딩은 open tracking에 쓰이는 비콘 click tracking이 달린 링크가 SendGrid가 아니라 서비스 사용자의 도메인을 향하게 해준다. 스팸 필터와 수신 서버는 이메일에 포함된 링크를 검사하여 이메일의 신뢰도를 평가하는데, 이 때 해당 링크가 연결된 루트 도메인의 평판(reputation)을 사용하게 된다. 링크 라벨링을 통해 클릭 트래킹 링크가 사용자가 컨트롤할 수 없는 도메인을 경유하지 않도록 함으로써 이메일 전달성의 향상을 기대할 수 있다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p>SendGrid Documentation</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.sendgrid.com/ui/account-and-settings/how-to-set-up-link-branding#cdn">https://docs.sendgrid.com/ui/account-and-settings/how-to-set-up-link-branding#cdn</a></li>
</ul>
<p>Mailchimp Documentation</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mailchimp.com/help/about-open-tracking/">https://mailchimp.com/help/about-open-tracking/</a></li>
<li><a target="_blank" rel="noopener" href="https://mailchimp.com/help/enable-and-view-click-tracking/">https://mailchimp.com/help/enable-and-view-click-tracking/</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/07/22/email-tracking/" data-id="ckw65m9v6000d4hoy74qua768" data-title="이메일 개봉/링크 클릭 추적하기" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/email/" rel="tag">email</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-web-domain-architecting" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/14/web-domain-architecting/" class="article-date">
  <time class="dt-published" datetime="2021-07-14T16:32:51.000Z" itemprop="datePublished">2021-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/14/web-domain-architecting/">도메인 구조의 설계</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>잘 설계된 도메인 구조는 아래와 같은 강점을 갖는다.</p>
<h2 id="1-Mental-model의-통일"><a href="#1-Mental-model의-통일" class="headerlink" title="1. Mental model의 통일"></a>1. Mental model의 통일</h2><p>서비스의 계층과 구조를 명확하게 정의하여, 사람들이 서비스를 이해하는 mental model을 통일하는 데 큰 역할을 한다. 이는 서비스의 구조가 복잡하면 복잡할수록 굉장한 강점으로 작용하며, 서비스 사용자(end-user)는 물론 서비스 기획/운영 측면의 효율을 크게 향상시킬 수 있다.</p>
<h2 id="2-SEO-SMO"><a href="#2-SEO-SMO" class="headerlink" title="2. SEO / SMO"></a>2. SEO / SMO</h2><p>검색 엔진이 데이터를 수집하는 방식에 맞게 도메인 구조를 설계하여 SEO/SMO를 효과적으로 진행할 수 있다.</p>
<h2 id="3-Analytics"><a href="#3-Analytics" class="headerlink" title="3. Analytics"></a>3. Analytics</h2><p>데이터를 효과적으로 수집하기 위해서는 이를 사전에 고려한 도메인 설계가 중요하다.<br>이를 바꿔 말하면, 도메인 구조를 잘 설계하기 위해서는</p>
<ol>
<li>서비스에 대한 명확한 이해</li>
<li>검색 엔진에 대한 지식</li>
<li>서비스 데이터 분석의 목적,방법론과 Analytics 툴에 대한 지식<br>과 같은, 서비스와 기반 기술에 대한 이해와 지식이 필요하다.</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/07/14/web-domain-architecting/" data-id="ckw65m9ve000n4hoydvp2goly" data-title="도메인 구조의 설계" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TIL/" rel="tag">TIL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/opinion/" rel="tag">opinion</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub-Pages/" rel="tag">GitHub Pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TIL/" rel="tag">TIL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Travis-CI/" rel="tag">Travis CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/email/" rel="tag">email</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fundamental/" rel="tag">fundamental</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/history/" rel="tag">history</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/infrastructure/" rel="tag">infrastructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opinion/" rel="tag">opinion</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/the-secret-life-of-programs/" rel="tag">the-secret-life-of-programs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/GitHub-Pages/" style="font-size: 10px;">GitHub Pages</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/TIL/" style="font-size: 10px;">TIL</a> <a href="/tags/Travis-CI/" style="font-size: 10px;">Travis CI</a> <a href="/tags/book/" style="font-size: 20px;">book</a> <a href="/tags/email/" style="font-size: 10px;">email</a> <a href="/tags/fundamental/" style="font-size: 20px;">fundamental</a> <a href="/tags/history/" style="font-size: 10px;">history</a> <a href="/tags/infrastructure/" style="font-size: 10px;">infrastructure</a> <a href="/tags/network/" style="font-size: 10px;">network</a> <a href="/tags/opinion/" style="font-size: 10px;">opinion</a> <a href="/tags/the-secret-life-of-programs/" style="font-size: 20px;">the-secret-life-of-programs</a> <a href="/tags/web/" style="font-size: 10px;">web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">11월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">10월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">8월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">7월 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/17/hexo-travis-ghpage/">Hexo 튜토리얼: Travis CI를 사용한 Github Pages 블로그 운영</a>
          </li>
        
          <li>
            <a href="/2021/10/05/video-through-web-0/">Adobe Flash와 ActiveX</a>
          </li>
        
          <li>
            <a href="/2021/08/06/what-is-ssl-certificate/">SSL/TLS와 인증서의 이해</a>
          </li>
        
          <li>
            <a href="/2021/08/01/tslop-05/">The Secret Life of Programs - 05. Computer Architecture</a>
          </li>
        
          <li>
            <a href="/2021/08/01/tslop-04/">The Secret Life of Programs - 04. Computer Anatomy</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 JY<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>