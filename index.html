<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>bastionsofwill</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="bastionsofwill">
<meta property="og:url" content="https://bastionsofwill.github.io/index.html">
<meta property="og:site_name" content="bastionsofwill">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="JY">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="bastionsofwill" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">bastionsofwill</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="검색"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="검색"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://bastionsofwill.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ssh-local-port-forwarding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/28/ssh-local-port-forwarding/" class="article-date">
  <time class="dt-published" datetime="2022-06-28T21:23:49.000Z" itemprop="datePublished">2022-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/28/ssh-local-port-forwarding/">Local Port Forwarding</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SSH-Port-Forwarding과-그-종류"><a href="#SSH-Port-Forwarding과-그-종류" class="headerlink" title="SSH Port Forwarding과 그 종류"></a>SSH Port Forwarding과 그 종류</h2><ul>
<li>SSH Tunneling이라고도 부름</li>
<li>특정 포트를 다른 <em>연결에 forwarding</em>하는 행위 </li>
<li>프록시와 유사한 역할을 수행</li>
<li>Local, Remote, Dynamic 포트 포워딩이 있음</li>
</ul>
<h2 id="Local-Port-Forwarding"><a href="#Local-Port-Forwarding" class="headerlink" title="Local Port Forwarding"></a>Local Port Forwarding</h2><p>Local port forwarding은 말 그대로 localhost(SSH 클라이언트)의 특정 포트를 다른 연결로 forward한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L &lt;<span class="built_in">local</span> port&gt;:&lt;target server&gt;:&lt;target port&gt; &lt;username&gt;@&lt;remote server&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;local port&gt;: SSH 터널링의 시작점으로 사용될 SSH 클라이언트가 동작하는 호스트의 포트</li>
<li>&lt;target server&gt;: 최종 목적지 서버</li>
<li>&lt;target port&gt;: &lt;target server&gt;의 포트</li>
<li>&lt;remote server&gt;: SSH 터널링을 통해 도달하는, Gateway(Bastion) 역할을 하는 서버(SSH 서버)</li>
</ul>
<p>즉, 클라이언트 환경에서 위와 같은 프로세스가 실행되면, <code>localhost:&lt;local port&gt;</code>로 전달되는 요청은 <code>username@&lt;remote server&gt;</code>에서 <code>&lt;target server&gt;:&lt;target port&gt;</code>에 보내지는 요청으로 처리된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 123:localhost:456 root@1.2.3.4</span><br></pre></td></tr></table></figure>
<p><img src="/images/lfp_local.png"><br>이미지 출처: <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot</a></p>
<p>위 예시는 target server를 localhost, 즉 자기 자신(gateway server, SSH server, 1.2.3.4)으로 지정한 경우이다. 이 때는 접근이 허용된 어느 호스트(자기 자신을 포함하여)에서든 프로세스를 실행한 클라이언트의 123번 포트(아래 이미지의 <code>your host:123</code>)로 요청을 보내면, 해당 요청은 ssh 터널을 통해 <a href="mailto:&#x72;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#x2e;&#50;&#46;&#51;&#46;&#52;">&#x72;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#x2e;&#50;&#46;&#51;&#46;&#52;</a> –&gt; 127.0.0.1:456 연결로 forward된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 123:&lt;farawayhost&gt;:456 root@1.2.3.4</span><br></pre></td></tr></table></figure>
<p><img src="/images/lfp_faraway.png"><br>이미지 출처: <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot</a></p>
<p>반면 위와 같이 target server를 다른 farawayhost로 지정하여 포트 포워딩을 실행할 경우, 클라이언트의 123번 포트로 보내진 요청은 ssh 터널을 통해 1.2.3.4 –&gt; farawayhost:456으로 forward된다.</p>
<p>즉, Local Port Forwarding은 아래와 같은 기능을 수행한다.</p>
<blockquote>
<p>&lt;some_host&gt; –&gt; &lt;client_host&gt;:&lt;client_port&gt;<br>를 아래 연결로 forward한다.<br>&lt;remote_host&gt; –&gt; &lt;target_host&gt;:&lt;target_port&gt;</p>
</blockquote>
<h2 id="Local-Port-Forwarding의-이점"><a href="#Local-Port-Forwarding의-이점" class="headerlink" title="Local Port Forwarding의 이점"></a>Local Port Forwarding의 이점</h2><p>Local port forwarding을 통해, 불특정 다수(&lt;some_host&gt;)의 &lt;target_host&gt;:&lt;target_port&gt;로의 접근 제어를 &lt;client_host&gt;:&lt;client_port&gt;로의 접근 제어를 통해 관리할 수 있다.<br>즉 &lt;target_host&gt;:&lt;target_port&gt;는 &lt;remote_host&gt;(Bation Host의 역할을 수행)로부터의 접근만 허용하면 된다는 점에서 &lt;target_host&gt;를 보다 안전하게 관리할 수 있고, 보안&#x2F;시스템적 제약 사항을 우회하는 데에도 자주 쓰인다.<br>컨테이너 기반 환경에서는 특히 이러한 Local Port Forwarding을 요긴하게 사용할 수 있다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://linux.systemv.pe.kr/ssh-%ED%8F%AC%ED%8A%B8-%ED%8F%AC%EC%9B%8C%EB%94%A9/">https://linux.systemv.pe.kr/ssh-%ED%8F%AC%ED%8A%B8-%ED%8F%AC%EC%9B%8C%EB%94%A9/</a><br><a target="_blank" rel="noopener" href="https://blog.naver.com/PostView.naver?blogId=alice_k106&amp;logNo=221364560794">https://blog.naver.com/PostView.naver?blogId=alice_k106&amp;logNo=221364560794</a><br><a target="_blank" rel="noopener" href="https://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS5064906327">https://www.hanbit.co.kr/network/category/category_view.html?cms_code=CMS5064906327</a><br><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot</a><br><a target="_blank" rel="noopener" href="https://www.ssh.com/acadeclient/ssh/tunneling/example">https://www.ssh.com/acadeclient/ssh/tunneling/example</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/06/28/ssh-local-port-forwarding/" data-id="cl4ywirr7000ydjs766dl2q9u" data-title="Local Port Forwarding" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cookie-and-session" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/27/cookie-and-session/" class="article-date">
  <time class="dt-published" datetime="2022-06-27T15:33:29.000Z" itemprop="datePublished">2022-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/27/cookie-and-session/">cookie-and-session</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Stateless에게-State를"><a href="#Stateless에게-State를" class="headerlink" title="Stateless에게 State를"></a>Stateless에게 State를</h2><p>HTTP는 무상태(stateless) 프로토콜이다. 하지만 클라이언트와의 상호작용을 위해서는 서버가 클라이언트(사용자)의 상태(state)를 알 수 있어야 한다. 이를 위해 등장한 기술이 몇 종류 존재하는데, 쿠키, 세션, 웹 스토리지가 그것이다. </p>
<h2 id="쿠키-Cookie"><a href="#쿠키-Cookie" class="headerlink" title="쿠키(Cookie)"></a>쿠키(Cookie)</h2><p>쿠키는 서버가 클라이언트를 식별하고 클라이언트의 상태를 저장하기 위해 사용하는, <em>클라이언트에 대한 정보를 저장한 파일</em>이다.<br>브라우저는 서버의 응답으로부터 쿠키를 전달받아 클라이언트 환경에 key-value 형태로 저장하였다가, 추후 HTTP 요청 시 해당 도메인으로부터 등록된 <strong>모든</strong> 쿠키를 요청과 함께 전달한다.</p>
<p>클라이언트 입장에서, 쿠키에 자신의 정보가 저장되는 것은 탈취당할 요소를 추가하는 것이므로 보안적인 위협이 된다.<br>반면, 쿠키를 관리&#x2F;전달하는 주체는 클라이언트이므로 클라이언트 쪽에서는 이를 얼마든지 위&#x2F;변조하여 서버에게 전달할 수 있고, 따라서 서버 입장에서도 클라이언트가 전달하는 쿠키가 보안적 위험 요소로 작용할 수 있다.</p>
<p>위와 같은 단점이 존재함에도 불구하고, 쿠키는 여전히 널리 사용된다.<br>서버가 클라이언트를 식별하고 클라이언트의 상태에 따라 동작하기 위해서는 클라이언트의 정보가 반드시 어딘가에는 저장되어 있어야 하므로, 이를 위한 가장 간편한 해결책인 쿠키는 보안에 민감한 정보가 아닐 경우에 한해 가장 먼저 고려할 수 있는 수단이다. </p>
<h2 id="세션-Session"><a href="#세션-Session" class="headerlink" title="세션(Session)"></a>세션(Session)</h2><p>위에서 쿠키 방식의 단점 중 하나는, 클라이언트 쪽에서 위&#x2F;변조 또는 탈취한 쿠키를 사용할 경우, 서버 쪽에서 이를 탐지하고 해당 요청을 거부할 수 없다는 것이었다.<br>따라서, 그런 중요한 정보를 클라이언트 쪽에서 전달하는 대로 믿지 않고 서버에서 직접 사용자의 정보를 관리하는 해결책을 떠올릴 수 있고, 이를 일반적으로 세션 방식이라고 부른다.<br>다만 앞서 설명한 것처럼 HTTP는 stateless 프로토콜이므로 서버에서 일방적으로 클라이언트를 식별할 수 있는 방법은 없다. 따라서, 서버에 필요한 정보를 저장하여도 해당 정보와 그 주인(특정 클라이언트)를 매칭시키기 위해서는  클라이언트를 식별하기 위한 식별자 정보가 필요하고, 이를 위해 서버는 클라이언트 식별자로 사용할 수 있는 쿠키를 발급한다. </p>
<p>즉 <em>쿠키 방식</em>과 <em>세션 방식</em>이라고 흔히들 말하는 것에 반해, 엄밀히 따지자면 쿠키와 세션은 대립되는 선택지가 아니다. 세션 방식에서도 쿠키를 사용하기 때문이다.<br>하지만 세션을 사용한 사용자의 인증은 중요한 정보가 서버 측에 저장되어 불특정 클라이언트로부터의 위&#x2F;변조가 어렵고, 클라이언트의 정보가 탈취당한다 하여도 세션이 만료된다면, 즉 클라이언트의 브라우저가 종료되거나 서버 쪽에서 설정한 세션 시간이 경과되면 해당 값은 사용할 수 없는 값이 되어버리므로 비교적 안전하다.</p>
<p>물론 브라우저가 종료되면 사용자의 정보는 모두 사라지는 점은 때로는 단점으로 작용하여, 쿠키를 사용하여야 할 때도<br>있다.<br>또 대규모 시스템의 경우, 가용성을 확보하기 위해 여러 대의 서버를 사용하여 부하를 분산하게 되는데, 이러한 경우 한 클라이언트가 보내는 연속적인 요청을 한 서버가 맡아서 처리하지 않으면 사용자가 시스템을 정상적으로 사용할 수 없으므로, 세션 정보만을 처리하는 별도의 서버를 분리하여 운영하기도 한다.</p>
<h2 id="웹-스토리지-Web-Storage"><a href="#웹-스토리지-Web-Storage" class="headerlink" title="웹 스토리지(Web Storage)"></a>웹 스토리지(Web Storage)</h2><p>웹 스토리지는 비교적 최근에 등장한 기술로 HTML5 표준에서 정의되었으며, 쿠키와 유사하면서도 장&#x2F;단점이 존재하지만 쿠키의 단점을 보완해줄 수 있는 기술이다.<br>웹 스토리지는 만료 시간이 없는 로컬 스토리지와 탭 단위 휘발성을 갖는 세션 스토리지로 구분되어 데이터의 용도에 따라 저장 장소를 선택하여 데이터의 생애 주기를 보다 효과적으로 관리할 수 있어 보다 안전하다.<br>또, 존재하는 모든 정보가 매번 무조건 전송되는 쿠키와 달리, 웹 스토리지에 있는 데이터 중 어떤 데이터를 전송할 지 선택할 수 있으며, string값만 저장할 수 있었던 쿠키와 달리 Javascript 객체를 저장할 수 있게 되었다는 점도 보다 다양한 방식으로 HTTP를 사용할 수 있는 여지를 준다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://kamang-it.tistory.com/entry/Web%EC%A1%B0%EA%B8%88-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88%EB%8F%84%EB%8C%80%EC%B2%B4-%EC%99%9C-%EC%9D%B4%EB%A6%84%EC%9D%B4-%EC%BF%A0%ED%82%A4%EC%9D%B8%EA%B1%B8%EA%B9%8C-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-http-cookie">https://kamang-it.tistory.com/entry/Web%EC%A1%B0%EA%B8%88-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88%EB%8F%84%EB%8C%80%EC%B2%B4-%EC%99%9C-%EC%9D%B4%EB%A6%84%EC%9D%B4-%EC%BF%A0%ED%82%A4%EC%9D%B8%EA%B1%B8%EA%B9%8C-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-http-cookie</a><br><a target="_blank" rel="noopener" href="https://kamang-it.tistory.com/entry/Web%EC%A1%B0%EA%B8%88-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88%EC%84%9C%EB%B2%84%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9D%98-%EC%97%B0%EA%B2%B0%EA%B3%A0%EB%A6%AC-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-http-session-cookie%EC%99%80%EC%9D%98-%EB%B9%84%EA%B5%90">https://kamang-it.tistory.com/entry/Web%EC%A1%B0%EA%B8%88-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88%EC%84%9C%EB%B2%84%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9D%98-%EC%97%B0%EA%B2%B0%EA%B3%A0%EB%A6%AC-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-http-session-cookie%EC%99%80%EC%9D%98-%EB%B9%84%EA%B5%90</a><br><a target="_blank" rel="noopener" href="https://kamang-it.tistory.com/entry/Web%EC%A1%B0%EA%B8%88-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88cookie%EB%8A%94-%EB%84%88%EB%AC%B4-%EA%B5%AC%EC%8B%9D%EC%95%84%EB%83%90-%EC%9D%B4%EC%A0%9C%EB%B6%80%ED%84%B4-Web-Storage">https://kamang-it.tistory.com/entry/Web%EC%A1%B0%EA%B8%88-%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88cookie%EB%8A%94-%EB%84%88%EB%AC%B4-%EA%B5%AC%EC%8B%9D%EC%95%84%EB%83%90-%EC%9D%B4%EC%A0%9C%EB%B6%80%ED%84%B4-Web-Storage</a><br><a target="_blank" rel="noopener" href="https://kcizzang.tistory.com/entry/SessionStorage-%EC%99%80-LocalStorage-%EC%B0%A8%EC%9D%B4%EC%A0%90">https://kcizzang.tistory.com/entry/SessionStorage-%EC%99%80-LocalStorage-%EC%B0%A8%EC%9D%B4%EC%A0%90</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/06/27/cookie-and-session/" data-id="cl4ywirqv000kdjs7cwr00op3" data-title="cookie-and-session" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/" rel="tag">network</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-how-does-a-package-manager-work" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/22/how-does-a-package-manager-work/" class="article-date">
  <time class="dt-published" datetime="2022-06-22T16:18:43.000Z" itemprop="datePublished">2022-06-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/22/how-does-a-package-manager-work/">리눅스 패키지 매니저</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>패키지는 바이너리 실행 파일들과 그 메타데이터(configuration 파일, dependency 정보)의 모음이며, 일반적으로 DEB(데비안 계열), RPM(레드햇 계열) 등 다양한 아카이브 파일 형식으로 배포된다. 패키지 매니저는 아카이브 파일을 열고 지정된 위치에 바이너리 실행 파일을 위치시키고, 그 파일이 어떤 패키지에 속하는지 파악해 두었다가 패키지를 삭제할 때 이를 삭제한다.</p>
<p>또, 패키지 매니저는 아래와 같은 기능을 수행하여 패키지 관리를 용이하게 해준다.</p>
<ol>
<li>패키지 의존성 관리: 패키지 간 의존 관계를 분석하여 어떤 패키지를 설치&#x2F;제거할 경우 해당 패키지가 의존하는 다른 패키지들 역시 설치&#x2F;제거하여 패키지 간 의존 관계를 사용자가 직접 관리하지 않아도 효과적으로 패키지를 사용할 수 있게 한다.</li>
<li>패키지 버전 관리: 설치된 패키지들 중 리포지토리에 사용 가능한 업데이트가 있는 패키지가 있는지 확인하고 필요 시 업데이트하는 역할도 수행한다.</li>
</ol>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>리눅스 환경에서, 패키지 매니저가 설치 대상 패키지를 가져오는 가장 보편적인 방법은 리포지토리(여기서의 리포지토리란 소프트웨어 리포지토리로, git이나 SVN같은 VCS에서 사용하는 리포지토리와는 다른 개념이다.)에서 원하는 패키지를 가져오는 방식이다. 각 리눅스 배포판마다 실행이 가능한 패키지를 제공하는 리포지토리를 운영하므로, 이를 활용하면 사용자는 편리하게 환경에 맞는 패키지를 설치&#x2F;관리할 수 있다.<br><img src="/images/linux-package-manager-explanation.png"><br>만약 리포지토리에서 제공하지 않는 소프트웨어를 설치하여야 할 경우, 사용자는 패키지 매니저라는 툴이 존재하지 않던 시절처럼 직접 자신의 환경에서 실행이 가능하도록 소스 파일을 빌드하고 환경을 구성하여야 한다. 여기서 말하는 환경 구성은 소프트웨어 의존 요소의 관리, 바이너리 파일의 위치 지정 등을 포함하며, 이에 추가로 구성 스크립트나 makefile등을 사용하도록 설계된 소프트웨어도 있을 것이다. 이는 굉장히 번거로운 일이며, 설치한 패키지가 많을수록 그 관리의 복잡성은 증가하고 문제 발생의 여지도 크다. </p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://itsfoss.com/package-manager/">https://itsfoss.com/package-manager/</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Software_repository">https://en.wikipedia.org/wiki/Software_repository</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Package_manager">https://en.wikipedia.org/wiki/Package_manager</a><br><a target="_blank" rel="noopener" href="https://www.howtogeek.com/117579/htg-explains-how-software-installation-package-managers-work-on-linux/">https://www.howtogeek.com/117579/htg-explains-how-software-installation-package-managers-work-on-linux/</a><br><a target="_blank" rel="noopener" href="https://help.ubuntu.com/community/Repositories/Ubuntu">https://help.ubuntu.com/community/Repositories/Ubuntu</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/06/22/how-does-a-package-manager-work/" data-id="cl4ywirr3000tdjs78rdp5hm0" data-title="리눅스 패키지 매니저" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-travis-ci-error" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/12/travis-ci-error/" class="article-date">
  <time class="dt-published" datetime="2022-06-12T21:27:57.000Z" itemprop="datePublished">2022-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/12/travis-ci-error/">Travis CI 에러 조치</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="74-errored"><a href="#74-errored" class="headerlink" title="#74 errored"></a>#74 errored</h2><p>오랜만에 블로그에 포스트를 작성하고 블로그를 둘러보니, 이전에 작성한 불필요한 포스트가 보였다. 이를 로컬 디렉토리에서 삭제한 후, 블로그에 반영하기 위해 리포지토리 main 브랜치에 push하였다.<br>리포지토리는 Travis CI를 통해 빌드&#x2F;배포 자동화가 설정되어 있으므로, 여느 때와 같이 빌드&#x2F;배포 작업이 진행될거라 기대했지만, 빌드가 실패했다는 메일을 받게 되었다.<br><img src="/images/travis-error.jpg"><br>지난 11월에 블로그 프레임워크를 Hexo로 바꾸면서, Hexo 튜토리얼 문서를 보고 그대로 따라한 뒤(<a href="https://bastionsofwill.github.io/2021/11/17/hexo-travis-ghpage">https://bastionsofwill.github.io/2021/11/17/hexo-travis-ghpage</a>) 처음 겪는 빌드 실패여서 당혹스러웠으나, 몇 시간 전에 성공한 것이 실패한 이유는 당연히 안 해본 짓(포스트 삭제)을 했기 때문일 것으로 추정하고 해결을 미뤘다.<br>하지만 빌드 실패 결과를 살펴본 결과, 문제는 다른 곳에 있음을 알 수 있었다.</p>
<h2 id="Job-Log"><a href="#Job-Log" class="headerlink" title="Job Log"></a>Job Log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Worker information</span><br><span class="line">(생략)</span><br><span class="line">Build system information</span><br><span class="line">(생략)</span><br><span class="line">$ git <span class="built_in">clone</span> --depth=50 --branch=main https://github.com/bastionsofwill/bastionsofwill.github.io.git bastionsofwill/bastionsofwill.github.io</span><br><span class="line"></span><br><span class="line">Setting environment variables from repository settings</span><br><span class="line">$ <span class="built_in">export</span> GH_TOKEN=[secure]</span><br><span class="line"></span><br><span class="line">$ nvm install 16</span><br><span class="line"></span><br><span class="line">Setting up build cache</span><br><span class="line">$ <span class="built_in">export</span> CASHER_DIR=<span class="variable">$&#123;TRAVIS_HOME&#125;</span>/.casher</span><br><span class="line">$ Installing caching utilities</span><br><span class="line">attempting to download cache archive</span><br><span class="line">fetching main/cache--linux-xenial-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855--node-16.tgz</span><br><span class="line">found cache</span><br><span class="line">$ node --version</span><br><span class="line">v16.15.1</span><br><span class="line">$ npm --version</span><br><span class="line">8.11.0</span><br><span class="line">$ nvm --version</span><br><span class="line">0.39.1</span><br><span class="line">$ yarn --version</span><br><span class="line">1.22.18</span><br><span class="line"></span><br><span class="line">$ yarn --frozen-lockfile</span><br><span class="line">hexo generate</span><br><span class="line">(생략)</span><br><span class="line">The <span class="built_in">command</span> <span class="string">&quot;hexo generate&quot;</span> exited with 0.</span><br><span class="line"></span><br><span class="line">store build cache</span><br><span class="line">changes detected (content changed, file is created, or file is deleted):\n/home/travis/.npm/_logs/2022-06-09T17_42_37_173Z-debug-0.log\n</span><br><span class="line">changes detected, packing new archive</span><br><span class="line">uploading main/cache--linux-xenial-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855--node-16.tgz</span><br><span class="line">cache uploaded</span><br><span class="line"></span><br><span class="line">$ rvm $(travis_internal_ruby) --fuzzy <span class="keyword">do</span> ruby -S gem install dpl</span><br><span class="line">Installing deploy dependencies</span><br><span class="line">ERROR:  Error installing dpl-pages:</span><br><span class="line">	The last version of multipart-post (&gt;= 1.2, &lt; 3) to support your Ruby &amp; RubyGems was 2.2.0. Try installing it with `gem install multipart-post -v 2.2.0` and <span class="keyword">then</span> running the current <span class="built_in">command</span> again</span><br><span class="line">	multipart-post requires Ruby version &gt;= 2.6.0. The current ruby version is 2.4.5.335.</span><br><span class="line">Successfully installed public_suffix-3.0.3</span><br><span class="line">Successfully installed addressable-2.8.0</span><br><span class="line">/home/travis/.rvm/rubies/ruby-2.4.5/lib/ruby/site_ruby/2.4.0/rubygems/core_ext/kernel_require.rb:54:<span class="keyword">in</span> `require<span class="string">&#x27;: cannot load such file -- dpl/provider/pages (LoadError)</span></span><br><span class="line"><span class="string">	from /home/travis/.rvm/rubies/ruby-2.4.5/lib/ruby/site_ruby/2.4.0/rubygems/core_ext/kernel_require.rb:54:in `require&#x27;</span></span><br><span class="line">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/lib/dpl/provider.rb:93:<span class="keyword">in</span> `rescue <span class="keyword">in</span> block <span class="keyword">in</span> new<span class="string">&#x27;</span></span><br><span class="line"><span class="string">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/lib/dpl/provider.rb:68:in `block in new&#x27;</span></span><br><span class="line">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/lib/dpl/cli.rb:41:<span class="keyword">in</span> `<span class="built_in">fold</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/lib/dpl/provider.rb:67:in `new&#x27;</span></span><br><span class="line">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/lib/dpl/cli.rb:31:<span class="keyword">in</span> `run<span class="string">&#x27;</span></span><br><span class="line"><span class="string">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/lib/dpl/cli.rb:7:in `run&#x27;</span></span><br><span class="line">	from /home/travis/.rvm/gems/ruby-2.4.5/gems/dpl-1.10.16/bin/dpl:5:<span class="keyword">in</span> `&lt;top (required)&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">	from /home/travis/.rvm/gems/ruby-2.4.5/bin/dpl:23:in `load&#x27;</span></span><br><span class="line">	from /home/travis/.rvm/gems/ruby-2.4.5/bin/dpl:23:<span class="keyword">in</span> `&lt;main&gt;<span class="string">&#x27;</span></span><br><span class="line"><span class="string">failed to deploy</span></span><br></pre></td></tr></table></figure>
<p>에러가 난 부분을 보면, deploy dependencies를 설치하다가 <code>dpl-pages</code>에서 에러가 발생했고, <code>multipart-post</code>가 Ruby 2.6.0을 요구하는데 현재 버전이 2.4.5.335인 것이 문제로 보인다.</p>
<h2 id="errored"><a href="#errored" class="headerlink" title="errored?"></a>errored?</h2><p>먼저 Travis CI가 동작하는 과정에 대한 간략한 이해가 필요하다.<br>Travis CI가 수행할 작업을 정의하는 구조는 phase -&gt; job -&gt; stage -&gt; build로, 하나의 <em>job</em>은 아래와 같은 <em>phase</em>로 구성된다.</p>
<ol>
<li><code>before_install</code></li>
<li><code>install</code>: dependency의 설치</li>
<li><code>before_script</code></li>
<li><code>script</code>: build script 실행</li>
<li><code>before_cache</code>(OPTIONAL)</li>
<li><code>after_success/failure</code></li>
<li><code>before_deploy</code>(OPTIONAL)</li>
<li><code>deploy</code>(OPTIONAL)</li>
<li><code>after_deploy</code>(OPTIONAL)</li>
<li><code>after_script</code></li>
</ol>
<p><em>stage</em>는 이러한 job들이 병렬로(in parellel) 실행되는 그룹을 말하며, <em>build</em>는 이러한 stage들이 순차적으로 실행되는 그룹을 말한다.</p>
<p>하나 이상의 job이 실패할 경우 그 job이 속한 빌드는 비정상(break)이 되며, 비정상 빌드는 아래 세 가지 키워드 중 하나로 표시된다.</p>
<ul>
<li><em>errored</em>: <code>before_install</code>, <code>install</code>, <code>before_script</code>, <code>before_deploy</code> phase가 정상적으로 종료되지 않을 경우(non-zero exit code) 발생</li>
<li><em>failed</em>: <code>script</code> phase가 정상적으로 종료되지 않을 경우 발생</li>
<li><em>canceled</em>: 사용자에 의한 취소<br><code>after_success/failure</code>, <code>after_deploy</code>, <code>after_script</code>의 exit code는 빌드 결과에 영향을 미치지 않지만, 타임아웃이 발생했을 경우 빌드 결과는 <em>failed</em>로 표시된다.</li>
</ul>
<p>즉, 위의 job log를 살펴본 결과, <code>hexo generate</code>라는 1줄짜리 스크립트가 실행되는 <code>script</code> phase까지는 무사히 실행되었으나, <code>before_deploy</code> phase에서 deploy dependency를 설치하다가 오류가 나서 build가 errored로 표시된 것임을 확인할 수 있었다.</p>
<h2 id="dpl-pages와-multipart-post"><a href="#dpl-pages와-multipart-post" class="headerlink" title="dpl-pages와 multipart-post"></a>dpl-pages와 multipart-post</h2><p>에러가 난 지점에 대한 감은 잡을 수 있었다. 하지만 여전히 문제에 대한 지식은 많이 모자란 상황이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Installing deploy dependencies</span><br><span class="line">ERROR:  Error installing dpl-pages:</span><br><span class="line">	The last version of multipart-post (&gt;= 1.2, &lt; 3) to support your Ruby &amp; RubyGems was 2.2.0. Try installing it with `gem install multipart-post -v 2.2.0` and <span class="keyword">then</span> running the current <span class="built_in">command</span> again</span><br><span class="line">	multipart-post requires Ruby version &gt;= 2.6.0. The current ruby version is 2.4.5.335.</span><br></pre></td></tr></table></figure>
<p>에러 로그를 다시 살펴보면, <code>dpl-pages</code>를 설치하다가 에러가 발생하였고,  <code>multipart-post</code>가 요구하는 ruby 버전이 2.6.0 이상인 것이 문제임을 알 수 있었다. </p>
<p>첫번째로 든 의문은, ‘<code>dpl-pages</code>, <code>multipart-post</code>는 또 뭔데?’였다. ‘배포 작업을 수행하기 위해 필요한 무언가’ 정도로만 추정이 되는 상황이었으므로, Travis CI가 배포하는 방식에 대한 지식이 필요했다.</p>
<p>이전에 생각없이 hexo tutorial을 복붙하면서, 나는 인지하지 못한 채 Travis CI의 GitHub Pages Deployment 기능을 사용하고 있었다. </p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">pages</span></span><br><span class="line">  <span class="attr">skip-cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github-token:</span> <span class="string">$GH_TOKEN</span></span><br><span class="line">  <span class="attr">keep-history:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">local-dir:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>
<p>위의 yml 파일이 관련 설정으로, <code>provider: pages</code>를 비롯한 설정을 통해 <code>hexo generate</code>의 결과물인 public 디렉토리 하위 파일들을 타겟 브랜치(지정하지 않았으므로 기본값인 <code>gh-pages</code> 브랜치)에 push하는 기능이다.</p>
<p>해당 기능에 대한 Travis CI 문서 확인 결과, dpl이라는 루비 코드를 사용하는 것을 알 수 있었다. 하지만 여기서 결국 <code>dpl-pages</code>, <code>multipart-post</code>에 대한 내용은 결국 찾지 못했는데, ruby에 대한 지식이 없는 상황에서 dpl의 문서에는 관련 내용이 없기 때문이다. 하지만 dpl은 rubygem으로 publish&#x2F;관리되고 있다는 내용이 있었으므로, dpl, dpl-pages, multipart-post라는 gem에 대한 기본적인 정보는 찾을 수 있었다.</p>
<h2 id="갈림길"><a href="#갈림길" class="headerlink" title="갈림길"></a>갈림길</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Installing deploy dependencies</span><br><span class="line">ERROR:  Error installing dpl-pages:</span><br><span class="line">	The last version of multipart-post (&gt;= 1.2, &lt; 3) to support your Ruby &amp; RubyGems was 2.2.0. Try installing it with `gem install multipart-post -v 2.2.0` and <span class="keyword">then</span> running the current <span class="built_in">command</span> again</span><br><span class="line">	multipart-post requires Ruby version &gt;= 2.6.0. The current ruby version is 2.4.5.335.</span><br></pre></td></tr></table></figure>
<p>위의 메시지를 자세히 보면, 배경이 어떻든 결국 <code>multipart-post</code>라는 gem이 ruby <em>2.6.0</em> 이상을 요구하는 반면, 환경에 설치된 ruby는 <em>2.4.5.335</em> 버전인 것이 문제임을 알 수 있다.</p>
<p>따라서 이를 해결하기 위해서는 아래 두 가지 해결책을 떠올릴 수 있다.</p>
<ol>
<li>ruby 버전을 <em>2.6.0</em> 이상으로 올린다.</li>
<li><code>multipart-post</code>의 버전을 <em>2.2.0</em>으로 내린다.(에러 메시지에서 권장한 방법)</li>
</ol>
<p>두 방법 모두 Travis CI가 동작하는 환경에 대한 조작이 필요하므로, <code>.travis.yml</code> 파일을 건드려야 한다. 쉽게 끝날 수도 있겠지만 아닐 가능성이 더 커서 꺼려지는데, 어느 쪽이 더 쉽고 문제가 적을지를 생각했다.</p>
<h4 id="1안-ruby-버전-업그레이드"><a href="#1안-ruby-버전-업그레이드" class="headerlink" title="1안: ruby 버전 업그레이드"></a>1안: ruby 버전 업그레이드</h4><p>2안 같은 버전 다운그레이드는 결국 문제를 나중에 터지도록 미루는 것이라는 생각이 들었다. 또 몇 시간 전까지도 잘 동작하다가 에러가 발생한 상황이어서, ruby 2.6.0은 비교적 최근에 릴리즈된 버전일 것이라 예상했고, 새로운 버전을 쓰면 좋을 것이라는 생각이 들었다.<br>하지만 확인 결과, ruby 2.6.0의 릴리즈 일자는 2018년 말이고 2.6.10도 이미 지원 종료(EOL)되었다. 이를 알게 되니 ‘아직도 몇년 전 버전의 루비를 사용하는 것을 보니 역시 고수들도 dependency는 함부로 건드리기 어렵구나’ 라는 생각에 갑자기 버전 업그레이드가 부담스러워졌다.<br>애초에 에러 메시지에서도 <code>multiport-post</code>의 버전을 낮출 것을 권장하였으니, 2안에 대해 알아보는 것이 좋을 것 같다.</p>
<h4 id="2안-multipart-post-버전-다운그레이드"><a href="#2안-multipart-post-버전-다운그레이드" class="headerlink" title="2안: multipart-post 버전 다운그레이드"></a>2안: multipart-post 버전 다운그레이드</h4><p>몇 시간 전만 해도 되던 걸 안 되게 만든 주범으로 추정되는 <code>multipart-post</code>는 직접적으로 확인할 수는 없었지만 에러 메시지를 통해 추정하면, 몇 시간 새 2.2.0 이후 버전이 적용되면서 Travis CI의 가상환경에서 사용되던 ruby 버전과 충돌을 일으킨 것으로 추정된다.<br>확인을 위해 rubygems.org에서 <code>multipart-post</code>를 찾아본 결과, 2022년 6월 9일에 릴리즈된 2.2.2 버전은 ruby 2.6.0 이상을 요구하였다. 하지만, 그 다음날에 릴리즈된 2.2.3 버전은 ruby 2.3.0 이상으로 요구 조건이 완화되었다. 즉, <code>multipart-post</code> 2.2.3 버전을 사용하면 현재 버전인 2.4.335도 문제없이 사용이 가능한 것이다.</p>
<h2 id="고마워요-ioquatix"><a href="#고마워요-ioquatix" class="headerlink" title="고마워요, ioquatix!"></a>고마워요, ioquatix!</h2><p>따라서, <code>multipart-post</code>를 관리하는 고수님들의 빠른 조치(<a target="_blank" rel="noopener" href="https://github.com/socketry/multipart-post/pull/95">https://github.com/socketry/multipart-post/pull/95</a>) 덕에, 나는 아무 것도 하지 않아도 저절로 문제가 해결되는 기쁨을 누렸다. 실제로 아무 조치 없이 빌드를 재실행한 결과, 빌드에 성공하였다.<br>내가 Travis CI가 사용하는 ruby의 버전을 지정하는 방법을 배워야 하는 사태가 발생하기 전에 Travis CI팀이 default ruby 버전을 계속 업그레이드 해주길 바라면서, 또 이 포스트의 속편을 바로 작성해야 하는 일이 없기를 바라면서 성공한 빌드 로그로 포스트를 마친다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Installing deploy dependencies</span><br><span class="line">Logged <span class="keyword">in</span> as @bastionsofwill (bastionsofwill)</span><br><span class="line"></span><br><span class="line">Preparing deploy</span><br><span class="line"></span><br><span class="line">Deploying application</span><br><span class="line"><span class="built_in">cd</span> /tmp/d20220612-6975-s1zerh/work</span><br><span class="line">commit fc19656296bd70de2ed24bdb2bf1c36bea7e3b67</span><br><span class="line">Author: Deployment Bot (from Travis CI) &lt;deploy@travis-ci.org&gt;</span><br><span class="line">Date:   Sun Jun 12 12:07:27 2022 +0000</span><br><span class="line">    Deploy bastionsofwill/bastionsofwill.github.io to github.com/bastionsofwill/bastionsofwill.github.io.git:gh-pages</span><br><span class="line"> 2021/07/14/web-domain-architecting/index.html   | 251 ------------------------</span><br><span class="line"> 2021/07/22/email-tracking/index.html            |  13 +-</span><br><span class="line"> 2021/08/01/tslop-04/index.html                  |   8 +-</span><br><span class="line"> 2021/08/01/tslop-05/index.html                  |   8 +-</span><br><span class="line"> 2021/08/06/what-is-ssl-certificate/index.html   |   8 +-</span><br><span class="line"> 2021/10/05/video-through-web-0/index.html       |   8 +-</span><br><span class="line"> 2021/11/17/hexo-travis-ghpage/index.html        |   8 +-</span><br><span class="line"> 2021/11/19/what-is-dependabot/index.html        |   8 +-</span><br><span class="line"> 2021/12/13/log4j2-vulnerability/index.html      |   8 +-</span><br><span class="line"> 2022/01/12/encoding-and-video-codecs/index.html |   8 +-</span><br><span class="line"> ...</span><br><span class="line"> 48 files changed, 129 insertions(+), 925 deletions(-)</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line">Done. Your build exited with 0.</span><br></pre></td></tr></table></figure>

<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://hexo.io/ko/docs/github-pages">https://hexo.io/ko/docs/github-pages</a><br><a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/for-beginners">https://docs.travis-ci.com/user/for-beginners</a><br><a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment">https://docs.travis-ci.com/user/deployment</a><br><a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/deployment/pages/">https://docs.travis-ci.com/user/deployment/pages/</a><br><a target="_blank" rel="noopener" href="https://github.com/travis-ci/dpl">https://github.com/travis-ci/dpl</a><br><a target="_blank" rel="noopener" href="https://rubygems.org/gems/dpl-pages">https://rubygems.org/gems/dpl-pages</a><br><a target="_blank" rel="noopener" href="https://rubygems.org/gems/multipart-post">https://rubygems.org/gems/multipart-post</a><br><a target="_blank" rel="noopener" href="https://www.ruby-lang.org/ko/downloads/">https://www.ruby-lang.org/ko/downloads/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/06/12/travis-ci-error/" data-id="cl4ywirr80012djs7ghxn9kr5" data-title="Travis CI 에러 조치" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Travis-CI/" rel="tag">Travis CI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-magical-shell-script" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/09/magical-shell-script/" class="article-date">
  <time class="dt-published" datetime="2022-06-09T17:53:10.000Z" itemprop="datePublished">2022-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/09/magical-shell-script/">쉘 스크립트 기초</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="이게-대체-뭔-소리야"><a href="#이게-대체-뭔-소리야" class="headerlink" title="이게 대체 뭔 소리야"></a>이게 대체 뭔 소리야</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line">ID=$(<span class="built_in">dd</span> <span class="keyword">if</span>=/dev/random bs=8 count=1 2&gt;/dev/null | <span class="built_in">od</span> -An -tx1 | <span class="built_in">tr</span> -d <span class="string">&#x27; \t\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>AWS Lambda를 공부하던 중에 샘플 코드에 위와 같은 내용이 있었다.<br>이를 이해하는 데 제법 오랜 시간이 걸렸으나 그 과정에서 알게 된 것이 많다.</p>
<p>하향식으로 접근하면, 위 코드(쉘 스크립트)는 3개 행으로 구성되어 있으며, 아래와 같은 내용으로 구성된다.</p>
<ul>
<li>1행: shebang</li>
<li>2행: <code>set</code> 명령어와 그 옵션</li>
<li>3행: <code>$</code>, <code>|</code>, <code>dd</code>, <code>dev/random</code>, <code>2&gt;/dev/null</code>, <code>od</code>, <code>tr</code></li>
</ul>
<p>특히 3행은 외계어나 다름없어 보인다. 이를 하나씩 뜯어서 살펴보자.</p>
<h2 id="Shebang"><a href="#Shebang" class="headerlink" title="Shebang"></a>Shebang</h2><p><code>#</code>과 <code>!</code>의 조합으로 시작되기 때문에 이러한 이름이 붙었다.<br>따라서 ‘셔뱅’이라고 읽으며, <em>sha-bang</em>, <em>hash-bang</em>이라고도 한다. 프로그램으로서 실행되는 스크립트임을 알리기 위해 스크립트 시작점에 작성하는 문자열이며, 나머지 부분은 인터프리터 지시자로 해석된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>특정 경로에 존재하는 어떤 스크립트의 첫 행이 위와 같다면, Unix-like OS는 그 스크립트를 프로그램으로 인식하며, 지정한 인터프리터, 즉 <code>/bin/bash</code>를 실행하면서 해당 스크립트가 위치한 경로가 그 인수로 전달된다.</p>
<h2 id="set-eo-pipefail"><a href="#set-eo-pipefail" class="headerlink" title="set -eo pipefail"></a>set -eo pipefail</h2><p><code>set</code>은 로컬 환경변수의 조회 및 쉘 환경 설정 기능을 수행한다. 환경변수를 조회한다는 점에서 <code>env</code>명령어와 유사하지만, <code>env</code>명령어는 글로벌 환경변수의 조회만 가능하다는 점에서 그 차이가 있다.</p>
<ul>
<li><code>-e</code>옵션: 오류 발생 시 프로세스 중단</li>
<li><code>-o pipefail</code>옵션: pipe 오류 코드 승계<br>즉, <code>set -eo pipefail</code> 명령을 실행하면, 이후 실행되는 pipe로 연결된 스크립트 중 하나만 non-zero exit code를 반환하여도 프로세스가 중단된다.</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="|"></a>|</h2><p>파이프 명령어로, 파이프 왼쪽에 위치한 (출력)값을 오른쪽에 위치한 명령어의 입력으로 전달한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al | grep <span class="string">&quot;yml&quot;</span></span><br></pre></td></tr></table></figure>
<p>예를 들어, 위 스크립트는 <code>|</code> 왼쪽의 <code>ls -al</code>의 출력을 오른쪽 <code>grep &quot;yml&quot;</code>의 입력으로 전달한다.<br>따라서, <code>ls-al</code>의 출력값은 cli로 출력되지 않고 <code>grep &quot;yml&quot;</code>의 입력로 전달되며, 결과적으로 현재 디렉토리에 존재하는 파일과 디렉토리의 리스트(<code>ls -al</code>의 출력) <em>중에서</em> <code>yml</code>이라는 문자열을 포함하는 행만 출력된다.</p>
<h2 id="와-명령어-치환-Command-Substitution"><a href="#와-명령어-치환-Command-Substitution" class="headerlink" title="$와 명령어 치환(Command Substitution)"></a>$와 명령어 치환(Command Substitution)</h2><p>쉘 스크립트에서 <code>$</code>는 변수를 가리키기 위해 사용된다. 예를 들어, <code>$VAR</code>또는 <code>$&#123;VAR&#125;</code>과 같이 VAR라는 변수의 값에 접근할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">cat</span> file.txt)</span><br></pre></td></tr></table></figure>
<p>하지만 위의 예시에서 <code>$</code>는 변수의 값에 접근하기 위해 사용된 것이 아니라, 명령어 치환을 위해 사용되었다. <code>$(command)</code>형태의 스크립트는 자기 자신을 subshell 환경에서 <code>command</code> 명령어를 실행한 표준 출력으로 대체한다.<br>(다만 예시는 <code>$(&lt; file)</code>와 동치이며, <code>&lt;</code>를 사용하는 것이 더 빠르다.)</p>
<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>dd 명령어는 stdin을 stdout으로 복사하는 역할을 한다.</p>
<ul>
<li><code>bs=n</code>: input, output 블록 사이즈를 n byte로 설정한다.(디폴트: 512바이트)</li>
<li><code>count=n</code>: n개의 블록만 처리한다.</li>
<li><code>if=file</code> stdin 대신 file로부터 input을 받는다.<br>즉, &#x2F;dev&#x2F;random이라는 파일로부터 8바이트의 블록 1개를 읽어와서 출력하는 것으로 해석할 수 있다.<br>그런데 &#x2F;dev&#x2F;random은 뭘까…?</li>
</ul>
<h2 id="x2F-dev-x2F-random-x2F-dev-x2F-null"><a href="#x2F-dev-x2F-random-x2F-dev-x2F-null" class="headerlink" title="&#x2F;dev&#x2F;random, &#x2F;dev&#x2F;null"></a>&#x2F;dev&#x2F;random, &#x2F;dev&#x2F;null</h2><p>리눅스 파일 시스템에서는 모든 대상을 파일 또는 디렉토리로 추상화하여 관리한다. 디바이스에 입력&#x2F;출력을 실행하는 것은 해당 디바이스를 추상화한 파일에 쓰기&#x2F;읽기를 수행하는 것과 같다.<br>&#x2F;dev 디렉토리는 스페셜 파일 또는 디바이스 파일이 위치한 디렉토리이다. 대부분의 디바이스의 종류는 아래와 같이 크게 2가지로 나뉜다.</p>
<ul>
<li>블록 디바이스<ul>
<li>블록&#x2F;섹터 등의 단위로 데이터를 전송하는 디바이스</li>
<li>주로 데이터를 저장하는 역할을 수행</li>
<li>리눅스 파일 모드에서 b로 표시</li>
<li>하드디스크, CD&#x2F;DVD 등</li>
</ul>
</li>
<li>캐릭터 디바이스<ul>
<li>byte 단위로 데이터를 전송하는 디바이스</li>
<li>리눅스 파일 모드에서 c로 표시</li>
<li>키보드, 마우스 등</li>
</ul>
</li>
</ul>
<p>하지만 물리적 디바이스와 연결되지 않는 디바이스 파일도 있는데, 이를 pseudo-device라고 한다. 커널 레벨에서 동작하는 기능들을 제공하는데, &#x2F;dev 디렉토리에 있는 대표적인 pseudo-device들은 아래와 같다.</p>
<ul>
<li><code>/dev/null</code>: 모든 입력을 버리는 블랙홀과 같다. 출력(읽기)을 하면 <em>EOF</em>를 반환한다.</li>
<li><code>/dev/zero</code>: 마찬가지로 모든 입력을 무시하며, 출력 시 <em>null</em> 문자의 stream을 반환한다.</li>
<li><code>/dev/full</code>: 입력 시도시 <em>ENOSPC</em>(disk full) 에러를 반환하며, 출력 시 <em>null</em> 문자의 stream을 반환한다.</li>
<li><code>/dev/random</code>: 입력한 데이터는 엔트로피 풀에 추가되며, 출력 시 커널의 암호학적 유사난수 생성기(CSPRNG)에서 생성된 데이터를 출력한다.</li>
</ul>
<h2 id="2-gt"><a href="#2-gt" class="headerlink" title="2&gt;"></a>2&gt;</h2><p>컴퓨터 프로그램은 실행 환경과 통신하기 위한 <code>stdin</code>, <code>stdout</code>, <code>stderr</code>라는 3개의 데이터 스트림을 가지며, 각각 0, 1, 2라는 정수 file descriptor 값을 갖는다. 즉, 2&gt;는 표준 에러의 출력을 지정하는 스크립트이다.</p>
<h2 id="od"><a href="#od" class="headerlink" title="od"></a>od</h2><p>Octal Dump의 약어로, 특정 입력을 사용자가 지정한 포맷으로 출력한다.</p>
<ul>
<li><code>-A</code>: 입력의 주소값을 출력하는 방식을 지정한다. <code>d</code>, <code>o</code>, <code>x</code>, <code>n</code> 네 옵션이 있으며, 각각 decimal, octal, hexadecimal, no address이다.</li>
<li><code>-t</code>: 출력 포맷을 지정한다.<ul>
<li>a: ascii</li>
<li>c: default char set</li>
<li>d&#x2F;o&#x2F;u&#x2F;x: signed decimal&#x2F;octal&#x2F;unsigned decimal&#x2F;hexadecimal. 아래 size 지정자와 같이 쓰일 수 있다.<ul>
<li>C: char, 1 byte</li>
<li>S: short, 2 byte</li>
<li>I: Int, 4 byte</li>
<li>L: Long, 8 byte</li>
<li>1&#x2F;2&#x2F;4&#x2F;8: 10진수로 나타낸 바이트 수.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>translate. 입력값을 가공하여 출력한다.</p>
<ul>
<li><code>-C</code>&#x2F;<code>-c</code>: 입력값 중 특정 charater set을 <em>제외한</em> 나머지를 지정한 값으로 바꾼 값을 출력한다.</li>
<li><code>-d</code>: 입력값 중 특정 charater set을 지우고 출력한다.</li>
</ul>
<h2 id="그래서-이게-뭔-소리라고"><a href="#그래서-이게-뭔-소리라고" class="headerlink" title="그래서 이게 뭔 소리라고?"></a>그래서 이게 뭔 소리라고?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>
<p>이 스크립트는 bash로 실행되는 프로그램이다. &#x2F;bin&#x2F;bash를 실행한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -eo pipefail</span><br></pre></td></tr></table></figure>
<p>pipe 중 하나라도 fail(exit code가 0이 아님)이면 프로세스를 중단하라.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID=$(<span class="built_in">dd</span> <span class="keyword">if</span>=/dev/random bs=8 count=1 2&gt;/dev/null | <span class="built_in">od</span> -An -tx1 | <span class="built_in">tr</span> -d <span class="string">&#x27; \t\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>ID라는 변수에 세개의 쉘 스크립트를 아래와 같이 조합하여 할당한다.<br>1) 8 byte 크기의 랜덤한 값을<br>2) 1 byte 단위로 16진수 형태로 변환한 뒤<br>3) 공백, 탭, 개행문자를 제거한 값</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://github.com/awsdocs/aws-lambda-developer-guide/tree/main/sample-apps/blank-nodejs/1-create-bucket.sh">https://github.com/awsdocs/aws-lambda-developer-guide/tree/main/sample-apps/blank-nodejs/1-create-bucket.sh</a><br><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EC%85%94%EB%B1%85">https://ko.wikipedia.org/wiki/%EC%85%94%EB%B1%85</a><br><a target="_blank" rel="noopener" href="https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_set">https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_set</a><br><a target="_blank" rel="noopener" href="https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_set_-e">https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_set_-e</a><br><a target="_blank" rel="noopener" href="https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_set_-euxo_pipefail">https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_set_-euxo_pipefail</a><br><a target="_blank" rel="noopener" href="https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_env,/_set_%EC%B0%A8%EC%9D%B4%EC%A0%90">https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_env,\_set_%EC%B0%A8%EC%9D%B4%EC%A0%90</a><br><a target="_blank" rel="noopener" href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html">https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html</a><br><a target="_blank" rel="noopener" href="https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/dev.html">https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/dev.html</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Device_file">https://en.wikipedia.org/wiki/Device_file</a><br><a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki//dev/random">https://ko.wikipedia.org/wiki//dev/random</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Standard_streams">https://en.wikipedia.org/wiki/Standard_streams</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/06/09/magical-shell-script/" data-id="cl4ywirr6000wdjs75uqxgw45" data-title="쉘 스크립트 기초" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unix/" rel="tag">unix</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-terraform-lang-basics" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/20/terraform-lang-basics/" class="article-date">
  <time class="dt-published" datetime="2022-04-20T13:43:00.000Z" itemprop="datePublished">2022-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/20/terraform-lang-basics/">Terraform Language 기초</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Terraform은 오픈소스 IaaC툴이며, 이를 위해 자체 Configuration 언어인 Terraform Language를 사용한다. </p>
<h2 id="Terraform-Language-Elements"><a href="#Terraform-Language-Elements" class="headerlink" title="Terraform Language Elements"></a>Terraform Language Elements</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource <span class="string">&quot;aws_vpc&quot;</span> <span class="string">&quot;main&quot;</span> &#123;</span><br><span class="line">  cidr_block = var.base_cidr_block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;BLOCK TYPE&gt; <span class="string">&quot;&lt;BLOCK LABEL&gt;&quot;</span> <span class="string">&quot;&lt;BLOCK LABEL&gt;&quot;</span> &#123;</span><br><span class="line">  <span class="comment"># Block body</span></span><br><span class="line">  &lt;IDENTIFIER&gt; = &lt;EXPRESSION&gt; <span class="comment"># Argument</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Blocks: 컨테이너의 역할을 수행하며, 리소스 등 특정 개체의 설정을 나타낸다.<ul>
<li>block type: 모든 블록은 타입을 갖는다.</li>
<li>labels: 타입에 따라 라벨의 갯수가 정해진다.</li>
<li>body: 다른 Argument와 블록이 중첩될 수 있다.</li>
</ul>
</li>
<li>Arguments: name에 value를 할당하며, block 안에 존재한다.</li>
<li>Expressions: 참조&#x2F;조합되거나 그 자체로 어떤 값이 된다.</li>
</ul>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul>
<li>Module이란 여러 개의 구성 파일(<code>.tf</code> 또는 <code>.tf.json</code>)이 한 디렉토리에 모인 것을 말한다.</li>
<li>모듈은 같은(top) 레벨의 파일들만으로 구성되며, 하위 디렉토리는 별개의 모듈로 취급되어 구성에 자동으로 포함되지 않는다.</li>
<li>Terraform은 항상 하나의 root module 컨텍스트에서 실행되며, Terraform 구성(configuration)은 root 모듈과 그 child 모듈(root모듈이 호출한 모듈과 그 child)들의 트리 형태이다.</li>
<li><code>module</code> 블록을 통해 child 모듈을 호출할 수 있으며, 아래와 같은 argument를 갖는다.<ul>
<li><code>source</code>: child module의 configuration file path 또는 다운로드 주소</li>
<li><code>version</code>: child module 버전</li>
<li>input variables</li>
<li>meta-arguments: child 모듈을 호출하는 방식을 지정해줄 수 있ㄷ.</li>
</ul>
</li>
</ul>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li>Terraform Language에서 가장 중요한 요소</li>
<li>각 Resource 블록은 타입과 로컬 네임, 2개의 라벨을 가지며, 타입과 리소스의 조합은 각 resource의 id로 작용하므로 같은 모듈에서 unique해야 한다.</li>
<li>로컬 네임은 같은 모듈 스코프에서 해당 리소스를 참조하는데 사용된다.</li>
</ul>
<h3 id="Meta-arguments"><a href="#Meta-arguments" class="headerlink" title="Meta-arguments"></a>Meta-arguments</h3><ul>
<li><code>depends_on</code>: 의존성 명시</li>
<li><code>count</code>: 특정 갯수의 인스턴스를 생성(for_each와 동시 사용 불가)</li>
<li><code>for_each</code>: map 또는 string set으로 다수의 인스턴스를 생성(count와 동시 사용 불가)</li>
<li><code>provider</code>: non-default provider configuration 지정</li>
<li><code>lifecycle</code>: 리소스의 생성&#x2F;소멸 관련 조건 지정</li>
<li><code>provisioner</code>: resource 생성 후 별도 행동</li>
</ul>
<h3 id="Resource-Behavior"><a href="#Resource-Behavior" class="headerlink" title="Resource Behavior"></a>Resource Behavior</h3><ul>
<li>Resource 블록을 통해 새로운 객체가 생성될 경우, 해당 객체의 id가 Terraform state에 저장되어 관리된다.</li>
<li>이미 state에 존재하는 Resource 블록이 있을 경우, configuration과 객체를 비교하여 필요시 객체를 configuration에 맞게 update한다.</li>
</ul>
<h2 id="Data-Sources"><a href="#Data-Sources" class="headerlink" title="Data Sources"></a>Data Sources</h2><ul>
<li><code>data</code>블록은 ‘data source’와 ‘local name’ 2개의 라벨을 가지며, 특정 data source로부터 데이터를 읽어 와서 local name 아래에 결과를 export한다.</li>
<li><code>variable</code> 블록과 마찬가지로 참조에 의한 값을 할당한다는 공통점이 있지만, variable 블록은 Terraform configuration 안에서 정의되는 반면 data 블록은 클라우드 인프라, 애플리케이션 등 외부에서 발생하는 데이터를 참조한다는 차이점이 있다.</li>
</ul>
<h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><ul>
<li>Providers Terraform에서 클라우드&#x2F;SaaS&#x2F;기타 API 제공자와 상호작용하기 위해 사용하는 플러그인이다.</li>
<li>Provider는 resource 및 data source의 집합을 추가해 준다.</li>
</ul>
<h2 id="Variables-and-Outputs"><a href="#Variables-and-Outputs" class="headerlink" title="Variables and Outputs"></a>Variables and Outputs</h2><ul>
<li><code>variable</code> 블록은 input variable을 정의하는 데 쓰인다.<ul>
<li><code>default</code>: 디폴트 값</li>
<li><code>type</code>: value의 타입(string, number, bool + collections 등의 복합 타입)</li>
<li><code>description</code></li>
<li><code>validation</code>: <code>condition</code> argument를 통해 변수가 가질 수 있는 값의 조건을 지정할 수 있으며, <code>error_message</code>로 invalid할 경우 에러 메시지를 지정할 수 있다.</li>
<li><code>sensitive</code>: boolean. Terraform UI output에서 마스킹 여부를 결정</li>
<li><code>nullable</code></li>
</ul>
</li>
<li><code>output</code> 블록은 모듈 외부로 값을 export할 때 사용된다.<ul>
<li><code>value</code></li>
<li><code>description</code></li>
<li><code>sensitive</code></li>
<li><code>depends_on</code>: 의존 관계를 명시적(explicit)으로 표현할 때 쓰인다.</li>
</ul>
</li>
</ul>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://www.terraform.io/language">https://www.terraform.io/language</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/04/20/terraform-lang-basics/" data-id="cl4ywirr80011djs7ba1508a2" data-title="Terraform Language 기초" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Terraform/" rel="tag">Terraform</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/infrastructure/" rel="tag">infrastructure</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cntda-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/11/cntda-02/" class="article-date">
  <time class="dt-published" datetime="2022-04-11T01:16:50.000Z" itemprop="datePublished">2022-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/11/cntda-02/">주말 네트워크 공부 02 - 네트워크 애플리케이션의 원리와 HTTP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="네트워크-애플리케이션-구조"><a href="#네트워크-애플리케이션-구조" class="headerlink" title="네트워크 애플리케이션 구조"></a>네트워크 애플리케이션 구조</h2><h3 id="클라이언트-x2F-서버-구조"><a href="#클라이언트-x2F-서버-구조" class="headerlink" title="클라이언트&#x2F;서버 구조"></a>클라이언트&#x2F;서버 구조</h3><ul>
<li>웹 애플리케이션과 같이, 항상 켜져있는 서버 호스트가 다른 많은 클라이언트 호스트의 요청을 처리하는 구조</li>
<li>클라이언트는 직접 통신하지 않음</li>
<li>서버가 고정 IP주소라는 잘 알려진 주소를 가짐</li>
<li>하나의 서버 호스트가 클라이언트의 모든 요청을 처리하기 어려울 경우, 데이터 센터 등으로 가상 서버를 생성<h3 id="P2P-구조"><a href="#P2P-구조" class="headerlink" title="P2P 구조"></a>P2P 구조</h3></li>
<li>항상 켜져있는 기반 서버에 최소 의존 또는 전혀 의존하지 않음</li>
<li>간헐적으로 연결된 호스트 쌍이 서로 직접 통신</li>
<li>클라이언트-서버 구조와 P2P 요소를 결합한 하이브리드 구조도 존재</li>
<li>자가 확장성을 가지며, 비용 효율적</li>
</ul>
<h2 id="프로세스-간-통신"><a href="#프로세스-간-통신" class="headerlink" title="프로세스 간 통신"></a>프로세스 간 통신</h2><ul>
<li>서로 다른 2개의 종단 시스템에서 각각의 프로세스는 메시지 교환을 통해 통신<h3 id="프로세스-네트워크-인터페이스"><a href="#프로세스-네트워크-인터페이스" class="headerlink" title="프로세스 - 네트워크 인터페이스"></a>프로세스 - 네트워크 인터페이스</h3></li>
<li>프로세스는 소켓(socket, 호스트의 애플리케이션 레이어와 트랜스포트 레이어 간 인터페이스)을 통해 네트워크로 메시지를 주고받음</li>
<li>애플리케이션 개발자는 트랜스포트 계층에는 트랜스포트 프로토콜의 선택과 약간의 매개변수만 통제가 가능</li>
</ul>
<h2 id="TCP와-UDP"><a href="#TCP와-UDP" class="headerlink" title="TCP와 UDP"></a>TCP와 UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>연결 지향형 서비스: 클라이언트와 서버는 전송 제어 정보를 교환하는 핸드셰이크 단계를 거친 후에 연결이 생성되어 양방향 메시지 전달이 가능해지고, 메시지 전송이 끝나면 연결을 끊는다.</li>
<li>신뢰적 데이터 전송 서비스</li>
<li>SSL: 암호화를 제공하지 않는 TCP에 보안성을 갖추기 위해 애플리케이션 레이어에 구현된 암호화 프로토콜</li>
<li>혼잡 제어 방식: 인터넷의 전체 성능 향상을 위해 각 연결의 대역폭 조정 및 제한<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3></li>
<li>최소 서비스 모델: 비연결형, 비신뢰적 데이터 전송 서비스</li>
<li>혼잡 제어 방식 미포함</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul>
<li>HTTP는 클라이언트 프로그램(웹 브라우저)과 서버 프로그램(웹 서버)으로 구현된다.</li>
<li>웹 페이지를 구성하는 각 객체의 URL은 1)해당 객체가 존재하는 서버의 호스트 네임과 2)객체의 경로 이름을 가진다.</li>
<li>HTTP는 TCP를 기반으로 하며, 브라우저와 서버의 프로세스는 소켓 인터페이스를 통해 TCP 통신을 진행한다.</li>
<li>HTTP는 상태가 없다(stateless).</li>
</ul>
<h2 id="HTTP-메시지-포맷"><a href="#HTTP-메시지-포맷" class="headerlink" title="HTTP 메시지 포맷"></a>HTTP 메시지 포맷</h2><h3 id="HTTP-req-메시지"><a href="#HTTP-req-메시지" class="headerlink" title="HTTP req 메시지"></a>HTTP req 메시지</h3><ul>
<li>request 라인: HTTP req 메시지의 첫 번째 줄이다.<ul>
<li>메서드 필드(GET, POST, HEAD, PUT, DELETE, etc.)<ul>
<li>GET: URL에 해당하는 객체를 요청한다.</li>
<li>POST: 사용자가 입력한 form 정보를 전달을 포함한 객체를 요청한다.</li>
<li>HEAD: GET과 유사하나, 객체는 보내지 않고 HTTP 메시지 res만 요청한다.</li>
<li>PUT: 웹 서버에 업로드할 객체가 필요한 애플리케이션이 사용한다.</li>
<li>DELETE: 웹 서버에 있는 객체의 삭제를 요청한다.</li>
</ul>
</li>
<li>URL 필드</li>
<li>HTTP 버전 필드</li>
</ul>
</li>
<li>header 라인: HTTP req 메시지의 나머지 줄이다.<ul>
<li>Host: 객체가 존재하는 호스트 네임이며, 웹 프록시 캐시가 요구하는 정보이다.</li>
<li>Connection: 지속 연결을 사용할지 여부</li>
<li>User-agent: 브라우저 타입</li>
<li>Accept-language: 선호 언어</li>
</ul>
</li>
<li>entity body: GET에서는 empty 상태이며, POST에서는 사용자가 입력한 form 정보를 포함한다.<h3 id="HTTP-res-메시지"><a href="#HTTP-res-메시지" class="headerlink" title="HTTP res 메시지"></a>HTTP res 메시지</h3></li>
<li>초기 상태 라인<ul>
<li>HTTP 버전 필드</li>
<li>상태 코드 및 메시지<ul>
<li>200 OK</li>
<li>301 Moved Permanently</li>
<li>400 Bad Request</li>
<li>404 Not Found</li>
<li>505 HTTP Version Not Supported</li>
</ul>
</li>
</ul>
</li>
<li>header 라인:<ul>
<li>Connection: 클라이언트에게 메시지를 보낸 후 연결을 지속할지 여부</li>
<li>Date: 서버가 HTTP res를 생성하고 보낸 시간</li>
<li>Server: 웹 서버 타입(req의 User-agent와 유사)</li>
<li>Last-Modified: 객체 생성 또는 최근 수정 시간이며, 캐싱 기능에 중요하게 사용된다.</li>
<li>Content-Length: 객체 크기</li>
<li>Conent-Type: 객체 타입</li>
</ul>
</li>
<li>entity body</li>
</ul>
<h2 id="쿠키"><a href="#쿠키" class="headerlink" title="쿠키"></a>쿠키</h2><ul>
<li>HTTP는 stateless하므로, 서버가 사용자를 추적하기 위해 쿠키(cookie)를 사용한다.</li>
<li>쿠키는 아래와 같은 4개 요소로 작동한다.<ul>
<li>HTTP res 메시지 쿠키 헤더 라인: 서버는 사용자 식별을 위한 ID를 생성하고 Set-cookie: 헤더에 이를 포함한다.</li>
<li>브라우저 쿠키 파일: 브라우저는 이를 자신이 관리하는 쿠키 파일에 저장한다.</li>
<li>HTTP req 메시지 쿠키 헤더 라인: 브라우저는 쿠키 파일에 현재 사이트에서 발급받은 쿠키가 있을 경우 이를 Cookie: 헤더로 포함하여 req 메시지를 전달한다.</li>
<li>서버(사이트) 백엔드 데이터베이스: 쿠키로 식별한 각 사용자의 활동 정보가 저장된다.</li>
</ul>
</li>
</ul>
<h2 id="웹-캐싱"><a href="#웹-캐싱" class="headerlink" title="웹 캐싱"></a>웹 캐싱</h2><ul>
<li>웹 캐시는 프록시 서버라고도 불리며, origin을 대신하여 HTTP req를 처리해줄 수 있는 네트워크 개체이다.</li>
<li>이를 위해 자체 저장 디스크를 갖추고 최근 호출된 객체의 사본을 저장한다.</li>
<li>브라우저 설정을 통해 모든 HTTP 요청을 웹 캐시를 거치도록 구성할 수 있다.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/04/11/cntda-02/" data-id="cl4ywirqt000idjs789she6ye" data-title="주말 네트워크 공부 02 - 네트워크 애플리케이션의 원리와 HTTP" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cntda-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/10/cntda-01/" class="article-date">
  <time class="dt-published" datetime="2022-04-10T00:07:16.000Z" itemprop="datePublished">2022-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/10/cntda-01/">주말 네트워크 공부 01 - 컴퓨터 네트워크와 인터넷</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="구성요소로-본-인터넷"><a href="#구성요소로-본-인터넷" class="headerlink" title="구성요소로 본 인터넷"></a>구성요소로 본 인터넷</h2><ul>
<li>인터넷은 여러 개의 컴퓨팅 장치(종단 시스템)를 연결하는 컴퓨터 네트워크</li>
<li>종단 시스템은 통신 링크(물리 매체)와 패킷 스위치의 네트워크로 연결</li>
<li>packet &#x3D; segment(데이터의 조각) + header</li>
<li>가장 널리 사용되는 패킷 스위치는 라우터와 링크-레이어 스위치로, 최종 목적지 방향으로 패킷을 전달하는 역할을 수행하며, 링크-레이어 스위치는 주로 액세스 네트워크에서, 라우터는 네트워크 코어에서 사용</li>
</ul>
<h2 id="서비스-측면에서-본-인터넷"><a href="#서비스-측면에서-본-인터넷" class="headerlink" title="서비스 측면에서 본 인터넷"></a>서비스 측면에서 본 인터넷</h2><ul>
<li>인터넷에 접속된 종단 시스템(출발지)은 인터넷 인프라 구조에게 다른 종단 시스템(목적지)에서 수행되는 프로그램에 데이터를 어떻게 전달하도록 요구하는지 명시하는 API(Application Programing Interface)를 제공</li>
<li>API는 송신 프로그램이 따라야 하는 규칙의 집합이며, 인터넷은 이 규칙에 따라 데이터를 목적지로 전달</li>
</ul>
<h2 id="액세스-네트워크-네트워크-코어"><a href="#액세스-네트워크-네트워크-코어" class="headerlink" title="액세스 네트워크, 네트워크 코어"></a>액세스 네트워크, 네트워크 코어</h2><ul>
<li>액세스 네트워크: 종단 시스템 간 경로 중 출발지와 첫 번째 라우터를 연결하는 네트워크</li>
<li>네트워크 코어: 패킷 스위치와 링크의 메시(mesh)</li>
<li>링크, 스위치의 네트워크를 통한 데이터의 전송에는 회선 교환과 패킷 교환 방식이 존재</li>
</ul>
<h2 id="인터넷-프로토콜-스택"><a href="#인터넷-프로토콜-스택" class="headerlink" title="인터넷 프로토콜 스택"></a>인터넷 프로토콜 스택</h2><ul>
<li>네트워크 프로토콜은 레이어 구조를 가지며, 각 프로토콜은 한 레이어에 속하며, 상위 레이어는 하위 레이어의 서비스를 이용할 수 있다.</li>
<li>인터넷 프로토콜 스택은 Application, Transport, Network, Link, Physical 5개 레이어로 구성된다.<h3 id="Application-Layer"><a href="#Application-Layer" class="headerlink" title="Application Layer"></a>Application Layer</h3></li>
<li>인터넷에서 사용하는 애플리케이션 계층 프로토콜은 대표적으로 HTTP, SMTP, FTP등이 있다.</li>
<li>애플리케이션 레이어에서의 정보 패킷을 메시지(message)라 부른다.<h3 id="Transport-Layer"><a href="#Transport-Layer" class="headerlink" title="Transport Layer"></a>Transport Layer</h3></li>
<li>애플리케이션 레이어로부터 전달받은 메시지를 전송하는 서비스를 제공한다.</li>
<li>인터넷에서는 TCP, UDP 2가지의 트랜스포트 프로토콜이 사용된다.</li>
<li>트랜스포트 레이어에서의 정보 패킷을 세그먼트(segment)라 부른다.<h3 id="Network-Layer"><a href="#Network-Layer" class="headerlink" title="Network Layer"></a>Network Layer</h3></li>
<li>출발지 호스트의 트랜스포트 레이어로부터 전달받은 세그먼트를 목적지 호스트의 트랜스포트 레이어로 전송하는 서비스를 제공한다.</li>
<li>네트워크 레이어에서의 정보 패킷을 데이터그램(datagram)이라 부른다.</li>
<li>IP는 데이터그램의 필드 및 네트워크 요소(종단 시스템 및 라우터)가 각 필드에 어떻게 동작하는지 정의하는, 유일한 프로토콜이다.</li>
<li>라우팅 프로토콜 역시 네트워크 레이어에 속하며, 인터넷은 다양한 라우팅 프로토콜을 가지고 있다.<h3 id="Link-Layer"><a href="#Link-Layer" class="headerlink" title="Link Layer"></a>Link Layer</h3></li>
<li>한 노드(호스트 또는 패킷 스위치)에서 다른 노드로 패킷을 전달하는 서비스를 제공한다.</li>
<li>이더넷, 와이파이, DOCSIS(Data Over Cable Service Interface Specification) 등이 있다.</li>
<li>링크 레이어에서의 정보 패킷을 프레임(frame)이라 부른다.<h3 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h3></li>
<li>한 노드에서 다른 노드로 프레임 내부의 각 비트를 전달하는 기능을 담당한다.</li>
</ul>
<h2 id="캡슐화-Encapsulation"><a href="#캡슐화-Encapsulation" class="headerlink" title="캡슐화(Encapsulation)"></a>캡슐화(Encapsulation)</h2><p><img src="/images/network_layers.png"></p>
<ul>
<li>패킷은 각 레이어를 거치면서, 상위 계층에서 받은 정보에 헤더를 추가하면서 데이터를 캡슐화한다.</li>
</ul>
<h2 id="네트워크-공격"><a href="#네트워크-공격" class="headerlink" title="네트워크 공격"></a>네트워크 공격</h2><ul>
<li>호스트에서 악성코드 실행</li>
<li>네트워크 인프라 공격(DoS)</li>
<li>패킷 탐지(Sniffing)</li>
<li>패킷 위장(Spoofing)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/04/10/cntda-01/" data-id="cl4ywirqr000gdjs7emxe48fh" data-title="주말 네트워크 공부 01 - 컴퓨터 네트워크와 인터넷" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-encoding-and-video-codecs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/12/encoding-and-video-codecs/" class="article-date">
  <time class="dt-published" datetime="2022-01-12T13:04:09.000Z" itemprop="datePublished">2022-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/01/12/encoding-and-video-codecs/">인코딩과 비디오 코덱</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Video-Codecs-and-Encoding"><a href="#Video-Codecs-and-Encoding" class="headerlink" title="Video Codecs and Encoding"></a>Video Codecs and Encoding</h2><h3 id="Video-Encoding"><a href="#Video-Encoding" class="headerlink" title="Video Encoding"></a>Video Encoding</h3><p>비디오 인코딩이란 비디오 원본을 다양한 기기에 호환되는 디지털 형태로 변환하는 과정을 말한다. 라이브 스트리밍에서는 데이터의 빠른 전달과 재생을 위해 비디오 인코딩이 필수적이다.<br>인코딩은 다양한 기기 또는 소프트웨어에서 실행되며, 유명한 소프트웨어로는 Vmix, Wirecast, OBS Studio 등이 있다.<br>인코더는 비디오&#x2F;오디오 코덱을 사용하여 전달이 용이한 크기로 비디오 원본을 압축한다. 간단히 말하자면, 인코딩은 압축 과정, 코덱은 압축의 수단이라고 볼 수 있다.</p>
<h3 id="What-Is-a-Codec"><a href="#What-Is-a-Codec" class="headerlink" title="What Is a Codec?"></a>What Is a Codec?</h3><p>Codec은 coder-decoder, compressor-decompressor의 준말로, 스트리밍의 경우 저장 및 전송을 위해 손실 압축을 적용하며, 추후 재생을 위해 복원된다. H.264는 가장 보편적인 비디오 코덱이며, AAC(Advanced Audio Coding)은 가장 보편적인 오디오 코덱이다.</p>
<h3 id="What-Is-a-Video-Container-Format"><a href="#What-Is-a-Video-Container-Format" class="headerlink" title="What Is a Video Container Format?"></a>What Is a Video Container Format?</h3><p>압축 후, 스트림의 컴포넌트들은 wrapper 또는 파일 포맷으로 패키징된다. 이러한 파일은 오디오&#x2F;비디오 코덱, CC, 메타데이터를 포함한다. 보편적인 컨테이너로는 .mp4, .mov, .ts, .wmv 등이 있다.</p>
<h3 id="Video-Codecs-vs-Containers-What’s-the-Difference"><a href="#Video-Codecs-vs-Containers-What’s-the-Difference" class="headerlink" title="Video Codecs vs Containers: What’s the Difference?"></a>Video Codecs vs Containers: What’s the Difference?</h3><p>코덱은 비디오 원본을 압축하고 복원하며, 전송을 위해 손실 압축을 거치면서 데이터 손실이 발생한다. 반면 비디오 컨테이너는 비디오&#x2F;오디오 코덱, 자막이나 미리보기 이미지 등의 메타데이터를 모두 저장하여 어떤 프로그램이 스트림을 처리하는지를 결정한다.</p>
<h3 id="Best-Video-Codecs-for-Streaming"><a href="#Best-Video-Codecs-for-Streaming" class="headerlink" title="Best Video Codecs for Streaming"></a>Best Video Codecs for Streaming</h3><p>차세대 코덱은 높은 인코딩 성능과 질을 보여줄 수 있는 반면, 기기 호환성을 보장하기 위해서는 레거시 코덱도 지원하여야 한다. 일례로, 넷플릭스는 최신 코덱 지원을 지속적으로 추가하면서도 서비스 시작부터 지원하였던 VC1 코덱을 계속 지원한다.</p>
<h3 id="H-264-x2F-AVC-Advanced-Video-Coding"><a href="#H-264-x2F-AVC-Advanced-Video-Coding" class="headerlink" title="H.264&#x2F;AVC(Advanced Video Coding)"></a>H.264&#x2F;AVC(Advanced Video Coding)</h3><p>오늘날 대다수의 인코딩 결과는 H.264(&#x3D;AVC) 파일이다. 주로 AAC 오디오 코덱과 결합되어 사용되며 .mp4, .mov, .F4v, .3GP, .ts 컨테이너에 패키징될 수 있다.<br>H.264는 거의 모든 기기에서 재생이 가능하며, 높은 품질의 비디오 스트림을 전달하면서도 로열티에 대한 우려가 가장 적다. H.264는 넓은 기기 지원 범위를 바탕으로 높은 점유율을 보여주지만, 4K, HDR(High Dynamic Range) 컨텐츠에는 적합하지 않다. H.264는 빠른 인코딩 속도를 바탕으로 라이브 생성(Live Origination)- 과 Transcoding에 강점을 보이므로 low-latency streaming에 적합하다.</p>
<h3 id="VP9"><a href="#VP9" class="headerlink" title="VP9"></a>VP9</h3><p>Google이 개발한 VP9은 로열티가 없는 H.265의 오픈소스 대체 코덱이다. Google의 YouTube와 Chrome 브라우저가 VP9을 지원하며, 안드로이드 기기, Firefox, Safari, 신형 iOS 기기 역시 이를 지원한다. 또, 많은 WebRTC 워크플로우에서도 VP9을 사용한다. 고성능 비디오에 적합하면서 H.264에 이어 2위의 브라우저&#x2F;기기 호환성을 보여주어 VP9의 활용폭은 넓어지고 있으며, YouTube와 Netflix의 VP9 사용은 이러한 흐름을 주도할 것으로 보인다.</p>
<h3 id="H-265-x2F-HEVC-High-Efficiency-Video-Coding"><a href="#H-265-x2F-HEVC-High-Efficiency-Video-Coding" class="headerlink" title="H.265&#x2F;HEVC(High Efficiency Video Coding)"></a>H.265&#x2F;HEVC(High Efficiency Video Coding)</h3><p>H.264의 후속으로 MPEG(Moving Picture Experts Group, ISO&#x2F;IEC 산하 그룹)에서 개발된 H.265는 압축 효율성 향상과 8K 해상도 지원을 목표로 하며, 실제로 H.264보다 더 작은 결과물 파일을 생성하면서 스트림을 재생하는데 요구하는 대역폭은 더 낮으므로 고해상도 스트리밍에 적합하다. 하지만 코덱 사용 로열티와 특허, 저작권에 대한 불명확성이 있어서 시장 점유율과 호환성이 낮은 편이다. 다만, 대부분의 스마트TV(Living room device)에서 지원되기 때문에 고해상도 OTT 콘텐츠를 제공할 경우에는 H.265가 많이 사용된다.</p>
<h3 id="AV1-AOMedia-Video-1"><a href="#AV1-AOMedia-Video-1" class="headerlink" title="AV1(AOMedia Video 1)"></a>AV1(AOMedia Video 1)</h3><p>H.265의 로열티 문제로 인해 Amazon, Netflix, Google, Microsoft, Cisco, Mozila는 AOMedia(Alliance for Open Media)를 결성하여 H.265의 오픈소스 대체 코덱 AV1을 만들었다. 다만 역사가 짧기 때문에 점유율이 높지 않으며, 인코딩 시간이 오래 걸린다는 단점도 있다.</p>
<h3 id="Encoding-vs-Transcoding"><a href="#Encoding-vs-Transcoding" class="headerlink" title="Encoding vs. Transcoding"></a>Encoding vs. Transcoding</h3><p>Transcoding은 인코딩된 파일을 디코딩하여 변환하는 것을 말한다. 이는 데이터를 보다 일반적인 코덱으로 재인코딩하거나, 비디오를 저화질로 변환(transize)하거나, 파일의 비트레이트를 변환(transrate)하거나, 보다 확장성이 높은 프로토콜로 변환(transmux: transcode-multiplexing)하는 등 다양한 과정을 포함한다. 트랜스코딩이 끝나면, 미디어 서버는 파일을 다시 압축한다.</p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><p><a target="_blank" rel="noopener" href="https://www.wowza.com/blog/video-codecs-encoding">https://www.wowza.com/blog/video-codecs-encoding</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2022/01/12/encoding-and-video-codecs/" data-id="cl4ywirqy000pdjs799y7234u" data-title="인코딩과 비디오 코덱" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/streaming/" rel="tag">streaming</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-log4j2-vulnerability" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/13/log4j2-vulnerability/" class="article-date">
  <time class="dt-published" datetime="2021-12-13T14:02:39.000Z" itemprop="datePublished">2021-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/13/log4j2-vulnerability/">Log4j2 취약점(CVE-2021-44228)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Log4j2-취약점이란"><a href="#Log4j2-취약점이란" class="headerlink" title="Log4j2 취약점이란?"></a>Log4j2 취약점이란?</h2><p>CVE-2021-44228은 2021년에 발견된, 널리 사용되는 자바 기반의 loggin 패키지인 Log4j의 취약점이다. 이는 공격자가 원격 서버에서 코드를 실행하는(Remote Code Execution, RCE) 공격을 허용하기 때문에 심각한 위협이 된다. 해당 취약점은 Log4j 버전 2(2.0-beta-9부터 2.14.1)에 존재하며, 2.15.0 버전에서 패치되었다. </p>
<h2 id="JNDI와-LDAP"><a href="#JNDI와-LDAP" class="headerlink" title="JNDI와 LDAP"></a>JNDI와 LDAP</h2><p>Log4j 패키지는 2013년에 v2.0-beta-9에서 “JNDILookup plugin”을 추가하였다. JNDI는 Java Naming and Directory Interface의 약어로, Java 프로그램이 디렉토리에 위치하는 데이터에와 자원에 접근하기 위한 인터페이스이다. Java 프로그램은 JNDI와 LDAP(Lightweight Directory Access Protocol)을 사용하여 LDAP 서버에 접근, LDAP 서버에서 객체를 로드할 수 있는데, localhost(해당 Java 프로그램이 실행되는 머신)의 LDAP 서버 말고도 LDAP URL을 사용하여 인터넷에 연결된 임의의 머신에서 실행되는 LDAP 서버를 지정할 수 있다. 즉, 공격자가 특정 Java 프로그램의 LDAP URL을 수정할 수 있는 권한을 얻게 된다면 해당 프로그램이 실행되면서 공격자가 원하는 서버에 위치한 객체를 로드할 수 있다는 것이다.</p>
<h2 id="공격-시나리오"><a href="#공격-시나리오" class="headerlink" title="공격 시나리오"></a>공격 시나리오</h2><p>공격자가 Log4j를 통해 ${jndi:ldap:&#x2F;&#x2F;example.com&#x2F;a} 같은 형태의 문자열을 출력할 경우, Log4j는 example.com의 LDAP서버에 접근하여 객체를 반환하게 된다. 이는 Log4j가 ${prefix:name} 형태의 특수 구문을 지원하여 여러가지 Lookup을 지원하기 때문인데, key가 “:”을 포함할 경우 기본 prefix인 “java:comp&#x2F;env&#x2F;“가 붙지 않고 LDAP 서버에 쿼리가 발생한다.<br>따라서 공격자는 log가 발생하는 input을 찾아내어 ${jndi:ldap:&#x2F;&#x2F;example.com&#x2F;a} 형식의 log가 발생하도록 하면 자신이 원하는 LDAP 서버에 위치한 코드를 실행할 수 있다. 이는 Java 기반의 인터넷과 직접 상호작용(Internet facing)하는 소프트웨어의 일반적인 공격 시나리오이며, 인터넷과 직접 상호작용하지 않는 Java 기반의 소프트웨어도 시스템 간 데이터 전송을 통해 공격 대상이 될 수 있다. 따라서, Log4j를 사용하는 모든 Java 기반 시스템은 반드시 업데이트가 요구되는 상황이다. </p>
<h3 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/">https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/</a></li>
<li><a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/manual/lookups.html">https://logging.apache.org/log4j/2.x/manual/lookups.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bastionsofwill.github.io/2021/12/13/log4j2-vulnerability/" data-id="cl4ywirr4000udjs73sfg4wqs" data-title="Log4j2 취약점(CVE-2021-44228)" class="article-share-link">공유</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/" rel="tag">security</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">다음 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub-Pages/" rel="tag">GitHub Pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Terraform/" rel="tag">Terraform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Travis-CI/" rel="tag">Travis CI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/devops/" rel="tag">devops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/email/" rel="tag">email</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/history/" rel="tag">history</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/infrastructure/" rel="tag">infrastructure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/" rel="tag">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/streaming/" rel="tag">streaming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/the-secret-life-of-programs/" rel="tag">the-secret-life-of-programs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unix/" rel="tag">unix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weekend/" rel="tag">weekend</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">태그 클라우드</h3>
    <div class="widget tagcloud">
      <a href="/tags/GitHub-Pages/" style="font-size: 10px;">GitHub Pages</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Terraform/" style="font-size: 10px;">Terraform</a> <a href="/tags/Travis-CI/" style="font-size: 13.33px;">Travis CI</a> <a href="/tags/book/" style="font-size: 20px;">book</a> <a href="/tags/devops/" style="font-size: 10px;">devops</a> <a href="/tags/email/" style="font-size: 10px;">email</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/history/" style="font-size: 10px;">history</a> <a href="/tags/infrastructure/" style="font-size: 13.33px;">infrastructure</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/network/" style="font-size: 16.67px;">network</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/shell/" style="font-size: 10px;">shell</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/streaming/" style="font-size: 10px;">streaming</a> <a href="/tags/the-secret-life-of-programs/" style="font-size: 13.33px;">the-secret-life-of-programs</a> <a href="/tags/unix/" style="font-size: 10px;">unix</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/weekend/" style="font-size: 16.67px;">weekend</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">아카이브</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">6월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">4월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">1월 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">12월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">11월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">10월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">8월 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">7월 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">최근 포스트</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/28/ssh-local-port-forwarding/">Local Port Forwarding</a>
          </li>
        
          <li>
            <a href="/2022/06/27/cookie-and-session/">cookie-and-session</a>
          </li>
        
          <li>
            <a href="/2022/06/22/how-does-a-package-manager-work/">리눅스 패키지 매니저</a>
          </li>
        
          <li>
            <a href="/2022/06/12/travis-ci-error/">Travis CI 에러 조치</a>
          </li>
        
          <li>
            <a href="/2022/06/09/magical-shell-script/">쉘 스크립트 기초</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 JY<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>