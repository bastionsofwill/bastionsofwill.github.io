---
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
tags:
    - book
    - fundamental
---
# Computer Hardware - What it is and how it's built
## 1. The Internal Language of Computers
## 2. Combinatorial Logic
## 3. Sequential Logic
## 6. Communications Breakdown
# Behavior of Software
## 7. Organizing Data
### 기본 데이터 타입
    - 프로그래밍 언어마다 다양한 기본 데이터 타입(primitive data type)을 제공하는데, 타입에는 크기(비트 수)와 해석(부호 유무, 부동소수점 여부, 문자/포인터/불리언 등)의 측면이 존재한다.
    ![](/images/figure_7_1.png)
    - 포인터는 메모리 주소로 해석되는 아키텍처에 따라 결정되는 크기의 부호가 없는 정수이다.
    - 값이 0인 포인터인 NULL 포인터는 일반적으로 주소로 인정하지 않는다.
### 배열
    - 배열은 인덱스와 인덱스에 해당하는 원소를 갖는 자료구조이다.
    - 배열의 인덱스는 0번째 원소의 주소, 즉 기저 주소(base address)로부터의 오프셋으로 지정한다. 즉, 원소~1~은 원소~0~으로부터 원소의 데이터 크기(16비트 정수라면 2바이트) 떨어져 있다.
    - 인덱스 범위를 벗어나는 인덱스에 접근하면 문제가 생길 수 있으므로 조심하여야 한다.
### 비트맵
    - 데이터를 표현할 때, 기본 데이터가 너무 클 경우 비트의 배열인 비트맵을 사용하여 1 바이트로 8개의 데이터를 표시할 수 있으므로 훨씬 효율적으로 데이터를 표현할 수 있다.
    - 비트맵에 수행할 수 있는 기본연산은 set(1로 만들기), clear(0으로 만들기), 0과 비교, 1과 비교의 4가지 연산이다. 
    - 목표 비트 값을 읽어오기 위해서는 1) 해당 비트가 들어있는 바이트를 찾고, 2) 해당 바이트 내에서 다시 목표 비트를 찾는다.
    ```
    예시: 17번 비트에 접근하기
    ```
    - 목표 비트가 들어있는 바이트를 찾기 위해 정수 나눗셈을 사용한다. 즉 목표 비트가 들어있는 바이트를 n번째 바이트라 하면, n은 목표 비트의 인덱스를 8로 나눈 값의 몫이다. 이를 위해 3비트 오른쪽 시프트 연산을 수행한다(하위 3비트를 버린다).
    ``` c
    00010001 >> 3
    // 00000010 (바이트~2~에 17번 비트가 존재)
    ```
    - 목표 비트가 저장된 바이트를 찾았으면 해당 바이트 내의 목표 비트의 위치를 찾는데, 이는 목표 비트의 인덱스를 8로 나눈 값의 나머지(하위 3비트)이다 이를 위해 0x07과 AND 연산을 수행한다(AND 00000111).
    ``` c
    00010001 && 00000111
    // 00000001 (어떤 바이트의 비트~1~이 목표 비트)
    ```
    - 목표 비트의 위치(000~111 사이의 값)를 찾은 다음, 00000001을 왼쪽으로 해당 값만큼 시프트하여 목표 비트만 켜지고 나머지는 모두 꺼진 비트 마스크를 만든다.
    ``` c
    00000001 << 00000001
    // 00000010 (비트~1~만 켜진 비트마스크)
    ```
    - 목표 비트가 존재하는 바이트의 인덱스(n)과 비트마스크(B)를 사용하여 기본 연산을 쉽게 수행할 수 있다.
    ``` c
    // n = 2, B = 00000010
    // set
    byte~n~ = byte~n~ OR B
    // clear
    byte~n~ = byte~n~ AND (~B)
    // test for set bit
    (byte~n~ && B) != 0
    // test for clear bit
    (byte~n~ && B) == 0
    ```
    - 자원의 사용가능 여부를 검색하는 연산을 비트맵 구조 상에서 효율적으로 수행할 수 있다. 0이 하나라도 있는 바이트를 검색하고, 바이트 내에서 다시 0인 비트를 검색하면 비트를 하나씩 따로 검사하는것보다 효율적이다. 자원이 많을 경우, 바이트가 아니라 unsigned long long같은 가장 큰 기본 타입을 배열 원소로 사용할 경우 최초 검색을 8이 아니라 64 단위로 진행할 수 있으므로 더 효율적인 작업을 기대할 수 있다.
## 문자열
    - 문자열 연산 시, 문자열의 길이를 알아야 하느네, 문자열 데이터 안에 문자열 길이를 포함하는 것이 가장 편한 방법이다.
    - 문자열 안에 길이를 저장하는 경우, 1) 문자열 길이가 제한되거나 2) 길이를 저장하는 부가 비용인 문자열 길이를 표현하기 위한 바이트 수가 문자열 자체를 저장하는데 쓰이는 바이트보다 많아지는 문제가 발생한다. 
    - C 언어는 문자열을 위한 전용 데이터 타입이 없고, 1차원 바이트 배열을 사용한다. 이 때문에 C언어에서는 문자열의 원소인 1 바이트를 나타내는 데이터 타입의 이름이 char가 되었다.
    - C에서의 문자열은 길이를 저장하지 않고, 문자열 데이터 끝에 바이트를 하나 추가하여 NUL을 문자열 터미네이터로 사용하여 문자열의 끝을 표시한다.
    - 문자열 터미네이터를 사용하는 방식은 저장이 쉽지만 1) 문자열 길이를 알아내야 할 경우 문자열을 스캔하면서 NUL을 만날 때까지 문자 수를 세야 하고, 2) 문자열에 NUL 문자를 포함할 수 없다는 단점이 있다.
## 복합 데이터 타입
    - 기본 데이터 타입 이외에 사용자가 데이터 타입을 만들 수 있는데, 이를 구조체(structure)라 하고, 구조체 안의 데이터들을 멤버(member)라 한다.
    - 멤버들을 이어붙여 구조체를 만드는 과정에서, 메모리 정렬에 어긋나는 경우가 발생할 수 있다. 이를 방지하기 위해 프로그래밍 언어 도구는 패딩(padding)을 추가하여 메모리 정렬을 맞춘다.
    - C언어의 공용체(union)는 구조체와 다르게 멤버들이 메모리를 공유할 수 있도록 함으로써 같은 메모리 공간을 여러 가지 접근자를 통해 접근할 수 있게 해준다. 예를 들어, pixel이라는 공용체가 있다면, pixel.color라는 접근자로 R,G,B,alpha값에 한꺼번에 접근할 수 있고, pixel.components.red라는 접근자로 R값만 따로 접근할 수 있다.
## Singly Linked List
    - 배열은 원소의 개수 등의 데이터의 양이 정해져있지 않은 경우 부적합하다. 이는 데이터의 양이 기존 크기를 넘어설 때 더 큰 배열을 만들고 기존 데이터를 새 배열에 복사하는 작업을 거쳐야 하기 때문이다.
    - 링크드 리스트는 원소의 개수를 모를 때 배열보다 적합한 데이터 구조가 될 수 있다.
    - 가장 간단한 링크드 리스트는 1) next라는 다음 원소의 주소를 저장하는 포인터와 2) 현재 원소의 값을 표시하는 데이터, 2개의 멤버를 갖는 구조체로 구현할 수 있으며, 리스트의 맨 앞 원소를 head, 마지막 원소를 tail이라 부른다. 보통 tail의 next가 NULL 포인터가 되도록 구현한다.
    - 리스트와 배열의 가장 큰 차이는 메모리에서의 위치이다. 배열의 각 원소는 메모리에서 연속적으로 위치하지만, 리스트의 원소는 아무 위치에나 있을 수 있다.
    - 리스트에 원소를 추가할 때는 next 포인터를 수정하면 간단하지만, 삭제 시에는 삭제할 원소 E의 직전 원소 P가 E의 직후 원소 N을 가리키게 해야 하기때문에 좀 더 복잡하다.


## 8. Language Processing
## 9. The Web Browser
# Art of Programming
## 10. Application and System Programming
## 11. Shortcuts and Approximations
## 12. Deadlocks and Race Conditions
## 13. Security
## 14. Machine Intelligence
## 15. Real-World Considerations
