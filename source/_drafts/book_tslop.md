---
title: 한 권으로 읽는 컴퓨터 구조와 프로그래밍
tags:
    - book
    - fundamental
---
# Computer Hardware - What it is and how it's built
## 1. The Internal Language of Computers
## 2. Combinatorial Logic
## 3. Sequential Logic
## 6. Communications Breakdown
# Behavior of Software
## 7. Organizing Data
### 기본 데이터 타입
- 프로그래밍 언어마다 다양한 기본 데이터 타입(primitive data type)을 제공하는데, 타입에는 크기(비트 수)와 해석(부호 유무, 부동소수점 여부, 문자/포인터/불리언 등)의 측면이 존재한다.
![](/images/figure_7_1.png)
- 포인터는 메모리 주소로 해석되는 아키텍처에 따라 결정되는 크기의 부호가 없는 정수이다.
- 값이 0인 포인터인 NULL 포인터는 일반적으로 주소로 인정하지 않는다.

### 배열
- 배열은 인덱스와 인덱스에 해당하는 원소를 갖는 자료구조이다.
- 배열의 인덱스는 0번째 원소의 주소, 즉 기저 주소(base address)로부터의 오프셋으로 지정한다. 즉, 원소~1~은 원소~0~으로부터 원소의 데이터 크기(16비트 정수라면 2바이트) 떨어져 있다.
- 인덱스 범위를 벗어나는 인덱스에 접근하면 문제가 생길 수 있으므로 조심하여야 한다.

### 비트맵
- 데이터를 표현할 때, 기본 데이터가 너무 클 경우 비트의 배열인 비트맵을 사용하여 1 바이트로 8개의 데이터를 표시할 수 있으므로 훨씬 효율적으로 데이터를 표현할 수 있다.
- 비트맵에 수행할 수 있는 기본연산은 set(1로 만들기), clear(0으로 만들기), 0과 비교, 1과 비교의 4가지 연산이다. 
- 목표 비트 값을 읽어오기 위해서는 1) 해당 비트가 들어있는 바이트를 찾고, 2) 해당 바이트 내에서 다시 목표 비트를 찾는다.
```
예시: 17번 비트에 접근하기
```
- 목표 비트가 들어있는 바이트를 찾기 위해 정수 나눗셈을 사용한다. 즉 목표 비트가 들어있는 바이트를 n번째 바이트라 하면, n은 목표 비트의 인덱스를 8로 나눈 값의 몫이다. 이를 위해 3비트 오른쪽 시프트 연산을 수행한다(하위 3비트를 버린다).
``` c
00010001 >> 3
// 00000010 (바이트~2~에 17번 비트가 존재)
```
- 목표 비트가 저장된 바이트를 찾았으면 해당 바이트 내의 목표 비트의 위치를 찾는데, 이는 목표 비트의 인덱스를 8로 나눈 값의 나머지(하위 3비트)이다 이를 위해 0x07과 AND 연산을 수행한다(AND 00000111).
``` c
00010001 && 00000111
// 00000001 (어떤 바이트의 비트~1~이 목표 비트)
```
- 목표 비트의 위치(000~111 사이의 값)를 찾은 다음, 00000001을 왼쪽으로 해당 값만큼 시프트하여 목표 비트만 켜지고 나머지는 모두 꺼진 비트 마스크를 만든다.
``` c
00000001 << 00000001
// 00000010 (비트~1~만 켜진 비트마스크)
```
- 목표 비트가 존재하는 바이트의 인덱스(n)과 비트마스크(B)를 사용하여 기본 연산을 쉽게 수행할 수 있다.
``` c
// n = 2, B = 00000010
// set
byte[n] = (byte[n] || B)
// clear
byte[n] = (byte[n] && (~B))
// test for set bit
(byte[n] && B) != 0
// test for clear bit
(byte[n] && B) == 0
```
- 자원의 사용가능 여부를 검색하는 연산을 비트맵 구조 상에서 효율적으로 수행할 수 있다. 0이 하나라도 있는 바이트를 검색하고, 바이트 내에서 다시 0인 비트를 검색하면 비트를 하나씩 따로 검사하는것보다 효율적이다. 자원이 많을 경우, 바이트가 아니라 unsigned long long같은 가장 큰 기본 타입을 배열 원소로 사용할 경우 최초 검색을 8이 아니라 64 단위로 진행할 수 있으므로 더 효율적인 작업을 기대할 수 있다.

### 문자열
- 문자열 연산 시, 문자열의 길이를 알아야 하느네, 문자열 데이터 안에 문자열 길이를 포함하는 것이 가장 편한 방법이다.
- 문자열 안에 길이를 저장하는 경우, 1) 문자열 길이가 제한되거나 2) 길이를 저장하는 부가 비용인 문자열 길이를 표현하기 위한 바이트 수가 문자열 자체를 저장하는데 쓰이는 바이트보다 많아지는 문제가 발생한다. 
- C 언어는 문자열을 위한 전용 데이터 타입이 없고, 1차원 바이트 배열을 사용한다. 이 때문에 C언어에서는 문자열의 원소인 1 바이트를 나타내는 데이터 타입의 이름이 char가 되었다.
- C에서의 문자열은 길이를 저장하지 않고, 문자열 데이터 끝에 바이트를 하나 추가하여 NUL을 문자열 터미네이터로 사용하여 문자열의 끝을 표시한다.
- 문자열 터미네이터를 사용하는 방식은 저장이 쉽지만 1) 문자열 길이를 알아내야 할 경우 문자열을 스캔하면서 NUL을 만날 때까지 문자 수를 세야 하고, 2) 문자열에 NUL 문자를 포함할 수 없다는 단점이 있다.

### 복합 데이터 타입
- 기본 데이터 타입 이외에 사용자가 데이터 타입을 만들 수 있는데, 이를 구조체(structure)라 하고, 구조체 안의 데이터들을 멤버(member)라 한다.
- 멤버들을 이어붙여 구조체를 만드는 과정에서, 메모리 정렬에 어긋나는 경우가 발생할 수 있다. 이를 방지하기 위해 프로그래밍 언어 도구는 패딩(padding)을 추가하여 메모리 정렬을 맞춘다.
- C언어의 공용체(union)는 구조체와 다르게 멤버들이 메모리를 공유할 수 있도록 함으로써 같은 메모리 공간을 여러 가지 접근자를 통해 접근할 수 있게 해준다. 예를 들어, pixel이라는 공용체가 있다면, pixel.color라는 접근자로 R,G,B,alpha값에 한꺼번에 접근할 수 있고, pixel.components.red라는 접근자로 R값만 따로 접근할 수 있다.

### Singly Linked List
- 배열은 원소의 개수 등의 데이터의 양이 정해져있지 않은 경우 부적합하다. 이는 데이터의 양이 기존 크기를 넘어설 때 더 큰 배열을 만들고 기존 데이터를 새 배열에 복사하는 작업을 거쳐야 하기 때문이다.
- 링크드 리스트는 원소의 개수를 모를 때 배열보다 적합한 데이터 구조가 될 수 있다.
- 가장 간단한 링크드 리스트는 1) next라는 다음 원소의 주소를 저장하는 포인터와 2) 현재 원소의 값을 표시하는 데이터, 2개의 멤버를 갖는 구조체로 구현할 수 있으며, 리스트의 맨 앞 원소(노드)를 head, 마지막 원소를 tail이라 부른다. 보통 tail의 next가 NULL 포인터가 되도록 구현한다.
- 리스트와 배열의 가장 큰 차이는 메모리에서의 위치이다. 배열의 각 원소는 메모리에서 연속적으로 위치하지만, 리스트의 원소는 아무 위치에나 있을 수 있다.
- 리스트에 새 노드를 추가할 때는 next 포인터를 수정하면 간단하지만, 삭제 시에는 삭제할 노드 N~current~의 직전 원소 N~previous~가 N~current~의 직후 원소 N~next~을 가리키게 해야 하기때문에 좀 더 복잡하다.
- 삭제 작업을 수행하기 위해 previous와 current라는 2개의 포인터를 사용하여 아래와 같은 작업을 수행한다.
![](/images/figure_7_14.png)
    - current가 삭제할 노드가 될 때까지 previous와 current를 업데이트하는 것을 반복한다.
    - current가 삭제할 노드가 되면, current.next의 값을 아래 2개 중 하나로 업데이트한다.
        - head - previous가 NULL일때 (current가 head여서 N~next를 새로운 head로 지정함을 의미)
        - previous.next - previous가 head가 아닐 때 (current가 head가 아니어서 N~previous~가 N~next~를 가리키게 함을 의미)
- 위 절차는 이중 간접 주소 지정(double indirect addressing)을 통해 더 간결하게 수행할 수 있다.
![](/images/figure_7_15.png)
    - current에 노드가 아니라 노드의 주소를 저장하고, current가 삭제할 노드의 주소가 될 때까지 current를 current.next의 주소로 업데이트하는 것을 반복한다.
    - current가 삭제할 노드의 주소가 되면, 삭제할 노드의 next

### 동적 메모리 할당
- 새 노드를 할당할 때, 새 노드를 위한 메모리 영역이 필요하다. 5장의 프로그램 실행 문단에서, 프로그램이 실행될 때 진입점 명령어 이전에 런타임 라이브러리가 실행되면서 스택과 힙 영역을 설정한다고 하였다. MMU가 없는 시스템은 힙 영역 전체를 프로그램이 사용할 수 있고(스택, 인터럽트 벡터는 예외), MMU가 있는 시스템은 런타임 라이브러리가 프로그램에 필요한 용량을 판단하여 운영체제에게 필요한 메모리 용량을 요청한다.
- 배열 등의 변수가 사용하는 메모리는 정적이고, 리스트 노드같은 존재는 동적이며, 이러한 동적 대상에 사용할 메모리는 힙 영역에서 얻는다. 
- 이를 위해 프로그램은 힙을 관리할 수 있어야 하며, 사용 중인 메모리와 사용 가능한 메모리를 알아야 한다. C는 malloc과 free 함수를 통해 이런 작업을 수행한다.
- malloc 함수를 구현하는 방법 중에는 Singly Linked List를 사용하는 구현이 있는데, 힙은 여러 블록으로 나뉘고 각 블록에는 크기와 다음 블록에 대한 포인터가 포함된다.
- 처음에는 전체 힙을 한 블록으로 관리하다가, 프로그램이 메모리를 요청하면 malloc이 충분한 크기의 블록을 찾아 블록의 크기 및 링크를 조정하고 요청받은 공간에 대한 포인터를 반환한다. 반대로 free 함수로 해당 메모리를 해제하면 메모리가 다시 링크드 리스트에 추가된다.
- malloc이 가용 블록 리스트를 순회하다가, 두 가용 블록이 인접하면 둘을 합쳐서 하나의 큰 블록으로 만드는데, 메모리 할당 시 가용 블록 리스트를 스캔하게 되므로 호출 시 해당 작업을 수행하는 방법도 있다.
- 이렇게 링크드 리스트 구조로 malloc을 구현하면 next와 size 때문에 부가적인 비용이 발생한다.
- 할당하지 않은 메모리를 대상으로 free 함수를 호출하거나 해제한 메모리에 접근하는 등의 실수를 방지하기 위해 성능이 충분할 경우에는 모든 메모리를 정적으로 할당하는 것이 나을 수 있다.

### 더 효율적인 메모리 할당
- 문자열이 들어있는 링크드 리스트의 경우, 노드에 사용할 메모리와 문자열에 사용할 메모리를 모두 할당하여야 하는데, 이 경우 malloc의 부가 비용이 상대적으로 커질 수 있다.
- 노드와 문자열을 동시에 할당하면 노드와 문자열의 크기를 합한 후 거기에 패딩을 추가한 크기의 공간을 할당하여 부가 비용을 줄일 수 있으며, 메모리를 해제할 때에도 free를 한 번만 호출할 수 있다.

### 가비지 콜렉션
- 포인터로 존재하지 않는 메모리에 접근하거나 메모리 경계에 맞지 않는 메모리에 접근하면 에러가 발생하면서 프로그램이 중단된다.
- 포인터가 없고, malloc과 free를 하지 않으면서 동적 메모리 할당을 지원하는 언어는 가비지 콜렉션을 구현한다.
- 포인터 대신 참조를 사용하는 언어는 포인터를 추상화하여 같은 기능을 수행하면서 메모리 주소를 노출하지 않는다.
- 가비지 콜렉션을 사용하는 언어는 데이터 요소를 만들어내면서 해당 요소가 사용하는 메모리를 할당하는 new 연산자를 제공하는 경우가 많다.
- 이러한 요소가 삭제될 경우에 대응하는 연산자는 없는데, 언어의 런타임 환경이 변수의 환경을 추적해서 사용하지 않는 메모리를 자동으로 해제해주며, 이것이 가비지 콜렉션이다.
- 자동해제를 구현하는 방식은 많지만, 해당 메모리를 참조하는 변수와 참조를 참조하는 다른 요소이 없을 때 이를 해제해버리는 방식을 참조 카운팅이라 한다.
- 가비지 콜렉션은 실수의 여지를 줄여 주지만, 프로그래머가 직접 가비지 컬렉션 시스템을 제어할 수 없어서 프로그램이 메모리를 더 많이 사용하는 등의 문제가 발생한다.

### 이중 연결 리스트
- 단일 연결 리스트의 delete 함수는 삭제하려는 원소의 앞 원소를 찾아야 해서 상당히 느린데, 메모리를 더 쓰는 이중 연결 리스트 구조를 사용하면 이를 더 빠르게 수행할 수 있다.
- 노드에 다음 노드를 가리키는 포인터 뿐만 아니라 이전 노드를 가리키는 포인터를 갖는 이중 연결 리스트는 리스트 순회 없이 원소를 삽입/삭제할 수 있다.

### 계층적인 데이터 구조
- 바이너리 트리는 가장 단순한 계층적 구조로, 한 노드가 최대 2개의 자녀 노드를 가지는 트리이다.
- 균형이 깨진 트리 구조는 성능에 악영향이 있으므로 균형을 잡는 과정을 별도로 거치는 경우가 많다.

### 대용량 저장장치
- 디스크의 기본 단위는 블록(섹터)이고, 연속적인 블록은 클러스터라 불린다.
- 데이터는 사용 가능한 섹터가 있으면 위치와 관계없이 저장되는데, 이 과정에서 데이터를 저장하기에 충분한 양의 고정 크기의 블록을 여러 개 확보하여야 한다.
- 데이터를 메모리 상에서 관리할 때는 포인터로 참조하면 되지만, 메모리는 일시적이므로 장기 저장을 위해서는 디스크에 저장하기 위한 파일 이름과 이를 저장할 방법, 데이터가 저장될 디스크 블록을 연결하여야 한다.
- UNIX에서는 블록 중 일부를 아이노드(index + node)로 따로 지정하여, 파일의 데이터가 들어있는 블록의 인덱스와 아래와 같은 파일에 대한 여러 정보를 저장한다.
    - 파일 이름
    - 파일 소유자
    - 파일 크기
    - 파일 허가 내역
- 아이노드에는 직접 블록 포인터(실제로는 포인터가 아닌, 블록의 인덱스)가 12개가 있으며, 4,096*12 = 49,152바이트 이하의 데이터는 이를 사용하여 보관한다.
- 파일이 더 커지면 간접 블록을 사용하며, 블록을 32비트(2^2^B) 인덱스로 표시할 경우 4KiB(=2^12^B) 짜리 블록에 1024(2^10^)개의 인덱스까지 저장이 가능하므로 4MiB(2^12^*2^10^B) 공간까지 지원이 가능하며, 다중 간접 블록을 통해 다시 4TiB, 4PiB까지 지원이 가능하다.
- 디렉터리는 파일 이름과 파일 데이터를 가리키는 아이노드를 연결하는데, 디렉터리 역시 파일의 유형 중 하나이다. 따라서 디렉터리는 다른 디렉터리를 참조할 수 있고, 이로 인해 계층적 파일 시스템이 생긴다.
- 여러 아이노드가 같은 블록을 링크(참조)할 수 있으며, 이로 인해 같은 파일(같은 블록에 저장된 데이터)가 다른 디렉터리에 나타날 수 있다.
- 심볼릭 링크는 디렉터리에 대한 링크로, 이를 허용하면 파일 시스템 그래프에 무한루프가 발생할 수 있으므로 이를 방지할 필요가 있다.
- 가용 공간을 추적하기 위해 각 블록의 가용 여부를 1비트로 표기하는 비트맵 구조를 사용할 경우, 충분히 효율적이지만 파일 시스템 그래프와 비트맵 사이 동기화가 깨질 수 있다는 문제가 있다.
- 이러한 오류를 효율적으로 수정할 수 있도록 설계된 journaling 파일 시스템이 현재는 널리 쓰인다.

### 데이터베이스
- 바이너리 트리는 메모리에 들어가기 어려운 커다란 데이터를 저장하기에는 적합하지 않은데,  

## 8. Language Processing
## 9. The Web Browser
# Art of Programming
## 10. Application and System Programming
## 11. Shortcuts and Approximations
## 12. Deadlocks and Race Conditions
## 13. Security
## 14. Machine Intelligence
## 15. Real-World Considerations
